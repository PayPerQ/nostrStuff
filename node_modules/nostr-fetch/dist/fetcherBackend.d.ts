import { type EnsureRelaysOptions, type FetchTillEoseOptions, type NostrFetcherBackend, type NostrFetcherCommonOptions } from "@nostr-fetch/kernel/fetcherBackend";
import { type Filter, type NostrEvent } from "@nostr-fetch/kernel/nostr";
/**
 * Default implementation of `NostrFetchBackend`.
 */
export declare class DefaultFetcherBackend implements NostrFetcherBackend {
    #private;
    constructor(commonOpts: Required<NostrFetcherCommonOptions>);
    /**
     * Ensures connections to the relays prior to an event subscription.
     *
     * Returns URLs of relays *successfully connected to*.
     *
     * It should *normalize* the passed `relayUrls` before establishing connections to relays.
     */
    ensureRelays(relayUrls: string[], options: EnsureRelaysOptions): Promise<string[]>;
    /**
     * Closes all the connections to relays and clean up the internal relay pool.
     */
    shutdown(): void;
    /**
     * Fetches Nostr events matching `filters` from the relay specified by `relayUrl` until EOSE.
     *
     * The result is an `AsyncIterable` of Nostr events.
     * You can think that it's an asynchronous channel which conveys events.
     * The channel will be closed once EOSE is reached.
     *
     * If one of the following situations occurs, it is regarded as "failure".
     * In such a case, it should throw `FetchTillEoseFailedSignal`.
     *
     * - It couldn't establish connection to the relay
     * - Received a NOTICE message during the fetch
     * - A WebSocket error occurred during the fetch
     *
     * If the fetch was aborted (due to AbortController or auto abortion timer), it should throw `FetchTillEoseAbortedSignal`.
     */
    fetchTillEose(relayUrl: string, filter: Filter, options: FetchTillEoseOptions): AsyncIterable<NostrEvent>;
}
//# sourceMappingURL=fetcherBackend.d.ts.map