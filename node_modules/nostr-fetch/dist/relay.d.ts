import type { Filter, NostrEvent } from "@nostr-fetch/kernel/nostr";
type Callback<E> = E extends void ? () => void : (ev: E) => void;
export interface Relay {
    url: string;
    wsReadyState: number;
    connect(): Promise<Relay>;
    close(): void;
    prepareSub(filters: Filter[], options: SubscriptionOptions): Subscription;
    on<E extends RelayEventTypes>(type: E, cb: RelayEventCbTypes[E]): void;
    off<E extends RelayEventTypes>(type: E, cb: RelayEventCbTypes[E]): void;
}
export type RelayOptions = {
    connectTimeoutMs: number;
};
export declare const initRelay: (relayUrl: string, options: RelayOptions) => Relay;
export type WSCloseEvent = {
    code: number;
    reason: string;
    wasClean: boolean | undefined;
};
export type RelayConnectCb = Callback<void>;
export type RelayDisconnectCb = Callback<WSCloseEvent | undefined>;
export type RelayNoticeCb = Callback<string>;
export type RelayErrorCb = Callback<void>;
export type RelayEventCbTypes = {
    connect: RelayConnectCb;
    disconnect: RelayDisconnectCb;
    notice: RelayNoticeCb;
    error: RelayErrorCb;
};
export type RelayEventTypes = keyof RelayEventCbTypes;
type EoseEventPayload = {
    aborted: boolean;
};
export type SubEventCb = Callback<NostrEvent>;
export type SubEoseCb = Callback<EoseEventPayload>;
export type SubClosedCb = Callback<string>;
export type SubEventCbTypes = {
    event: SubEventCb;
    eose: SubEoseCb;
    closed: SubClosedCb;
};
export type SubEventTypes = keyof SubEventCbTypes;
export interface Subscription {
    subId: string;
    req(): void;
    close(): void;
    on<E extends SubEventTypes>(type: E, cb: SubEventCbTypes[E]): void;
    off<E extends SubEventTypes>(type: E, cb: SubEventCbTypes[E]): void;
}
export interface SubscriptionOptions {
    subId?: string;
    skipVerification: boolean;
    skipFilterMatching: boolean;
    abortSubBeforeEoseTimeoutMs: number;
}
export {};
//# sourceMappingURL=relay.d.ts.map