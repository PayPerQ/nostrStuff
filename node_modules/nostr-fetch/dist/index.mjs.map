{
  "version": 3,
  "sources": ["../../kernel/src/channel.ts", "../../../node_modules/@noble/hashes/src/_assert.ts", "../../../node_modules/@noble/hashes/src/crypto.ts", "../../../node_modules/@noble/hashes/src/utils.ts", "../../../node_modules/@noble/hashes/src/_sha2.ts", "../../../node_modules/@noble/hashes/src/sha256.ts", "../../kernel/node_modules/@noble/curves/src/abstract/utils.ts", "../../kernel/node_modules/@noble/curves/src/abstract/modular.ts", "../../kernel/node_modules/@noble/curves/src/abstract/curve.ts", "../../kernel/node_modules/@noble/curves/src/abstract/weierstrass.ts", "../../../node_modules/@noble/hashes/src/hmac.ts", "../../kernel/node_modules/@noble/curves/src/_shortw_utils.ts", "../../kernel/node_modules/@noble/curves/src/secp256k1.ts", "../../kernel/src/crypto.ts", "../../kernel/src/debugLogger.ts", "../../kernel/src/fetcherBackend.ts", "../../kernel/src/utils.ts", "../../kernel/src/nostr.ts", "../src/relay.ts", "../src/relayPool.ts", "../src/fetcherBackend.ts", "../src/types.ts", "../src/fetcherHelper.ts", "../src/fetcher.ts"],
  "sourcesContent": ["export interface Deferred<T> {\n  resolve(v: T | PromiseLike<T>): void;\n  reject(e?: unknown): void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class Deferred<T> {\n  promise: Promise<T>;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = (v) => {\n        resolve(v);\n      };\n      this.reject = (e) => {\n        reject(e);\n      };\n    });\n  }\n}\n\nexport interface ChannelSender<T> {\n  send(v: T): void;\n  error(e: unknown): void;\n  close(): void;\n\n  waitUntilDrained(): Promise<void>;\n  numBufferedItems(): number;\n}\n\ninterface ChannelIter<T> {\n  [Symbol.asyncIterator](): AsyncIterator<T, void, undefined>;\n}\n\nclass ChannelCloseSignal extends Error {\n  constructor() {\n    super(\"channel closed\");\n  }\n}\n\ntype ChannelMakeOptions = {\n  highWaterMark?: number | undefined;\n};\n\nexport class Channel<T> {\n  #sendQ: (() => Promise<T>)[] = [];\n  #recvQ: Deferred<T> | undefined;\n  #closed = false;\n\n  #iterAlreadyStarted = false;\n\n  // backpressure mode related\n  #highWaterMark: number;\n  #drainWaiter: Deferred<void> | undefined;\n\n  private constructor({ highWaterMark = undefined }: ChannelMakeOptions) {\n    this.#highWaterMark = highWaterMark ?? Number.POSITIVE_INFINITY;\n  }\n\n  /**\n   * Makes an asynchronous channel.\n   *\n   * Return a pair of a sender endpoint and an iterator which iterate over items sent to the channel.\n   *\n   * Specifying `highWaterMark` option enables the \"backpressure mode\".\n   * In this mode, a sender can wait until internal queue is free enough.\n   */\n  static make<T>(options?: ChannelMakeOptions): [ChannelSender<T>, ChannelIter<T>] {\n    const c = new Channel<T>(options ?? {});\n    return [c as ChannelSender<T>, c as ChannelIter<T>];\n  }\n\n  send(v: T) {\n    if (this.#recvQ !== undefined) {\n      this.#recvQ.resolve(v);\n      this.#recvQ = undefined;\n      return;\n    }\n    if (this.#closed) {\n      return;\n    }\n    this.#sendQ.push(() => Promise.resolve(v));\n  }\n\n  error(e?: unknown) {\n    if (this.#recvQ !== undefined) {\n      this.#recvQ.reject(e);\n      this.#recvQ = undefined;\n      return;\n    }\n    if (this.#closed) {\n      return;\n    }\n    this.#sendQ.push(() => Promise.reject(e));\n  }\n\n  close() {\n    if (!this.#closed) {\n      this.#closed = true;\n\n      if (this.#recvQ !== undefined) {\n        // cancel reception\n        this.#recvQ.reject(new ChannelCloseSignal());\n        this.#recvQ = undefined;\n      }\n    }\n  }\n\n  waitUntilDrained(): Promise<void> {\n    if (this.#drainWaiter !== undefined) {\n      return this.#drainWaiter.promise;\n    }\n\n    if (this.#sendQ.length <= this.#highWaterMark) {\n      return Promise.resolve();\n    }\n    // sendQ have overflowed -> wait until drained\n    this.#drainWaiter = new Deferred();\n    return this.#drainWaiter.promise;\n  }\n\n  numBufferedItems(): number {\n    return this.#sendQ.length;\n  }\n\n  private get isCompleted(): boolean {\n    return this.#closed && this.#sendQ.length === 0;\n  }\n\n  private recv(): () => Promise<T> {\n    if (this.#sendQ.length > 0) {\n      const next = this.#sendQ.shift() as () => Promise<T>;\n\n      if (this.#drainWaiter !== undefined && this.#sendQ.length <= this.#highWaterMark) {\n        // notify to sender that sendQ have been drained enough\n        this.#drainWaiter.resolve();\n        this.#drainWaiter = undefined;\n      }\n\n      return next;\n    }\n    if (this.#recvQ !== undefined) {\n      return () => Promise.reject(Error(\"Double receive is not allowed\"));\n    }\n    const d = new Deferred<T>();\n    this.#recvQ = d;\n    return () => d.promise;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    if (this.#iterAlreadyStarted) {\n      throw Error(\"Iterating a single channel in multiple location is not allowed\");\n    }\n\n    this.#iterAlreadyStarted = true;\n    while (true) {\n      try {\n        if (this.isCompleted) {\n          break;\n        }\n        yield await this.recv()();\n      } catch (err) {\n        if (err instanceof ChannelCloseSignal) {\n          // closed while awaiting fulfillment of recv queue\n          break;\n        } else {\n          throw err;\n        }\n      }\n    }\n  }\n}\n", "function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n", "// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!isBytes(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    if (!isBytes(a)) throw new Error('Uint8Array expected');\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    if (!isBytes(a)) throw new Error('Uint8Array expected');\n    sum += a.length;\n  }\n  let res = new Uint8Array(sum);\n  let pad = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n: bigint, pos: number, value: boolean) => {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  numberToBytesBE,\n  numberToBytesLE,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) \u2261 1    if a is a square (mod p)\n  // (a | p) \u2261 -1   if a is not a square (mod p)\n  // (a | p) \u2261 0    if a \u2261 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) \u2261 -1 and set c \u2261 zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be \u2261 -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P \u2261 3 (mod 4)\n  // \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q \u2261 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P \u2261 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return (x: T): boolean => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  const constTimeNegate = (condition: boolean, item: T): T => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = (W: number) => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint) {\n      let p = c.ZERO;\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n     * - \uD835\uDC4A is the window size\n     * - \uD835\uDC5B is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = opts(W);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = opts(W);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    wNAFCached(P: T, precomputesMap: Map<T, T[]>, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      // @ts-ignore\n      const W: number = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    },\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y\u00B2 = x\u00B3 + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { CHash, Hex, PrivKey, ensureBytes } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | true;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\n\n/**\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n */\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  CURVE: ReturnType<typeof validatePointOpts<T>>;\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  _parseInt(data: Uint8Array): { d: bigint; l: Uint8Array } {\n    const { Err: E } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\n    if (res[0] === 0x00 && !(res[1] & 0b10000000))\n      throw new E('Invalid signature integer: unnecessary leading zero');\n    return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!ut.isBytes(data)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return { r, s };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n    const slice = (s: string): string => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n    const h = (num: number | bigint) => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>): CurvePointsRes<T> {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y\u00B2 = x\u00B3 + ax + b: Short weierstrass curve formula\n   * @returns y\u00B2\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n  function assertGE(num: bigint) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (ut.isBytes(key)) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n    assertGE(num); // num in range [1..N-1]\n    return num;\n  }\n\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) \u220B (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(\n      readonly px: T,\n      readonly py: T,\n      readonly pz: T\n    ) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      if (this.is0()) {\n        // (0, 1, 0) aka ZERO is invalid in most contexts.\n        // In BLS, ZERO can be serialized, so we allow it.\n        // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n        if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n        throw new Error('bad point: ZERO');\n      }\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n      const { x, y } = this.toAffine();\n      // Check if x, y are valid field elements\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y\u00B2\n      const right = weierstrassEquation(x); // x\u00B3 + ax + b\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    private is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp: Point[]) => {\n        const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(n: bigint): Point {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n      if (n === _1n) return this;\n      const { endo } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n);\n\n      // Apply endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      assertGE(scalar);\n      let n = scalar;\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const { endo } = CURVE;\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(n);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) \u220B (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      const { px: x, py: y, pz: z } = this;\n      const is0 = this.is0();\n      // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function isValidFieldElement(num: bigint): boolean {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n  function modN(a: bigint) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y\u00B2 = x\u00B3 + ax + b\n        let y = Fp.sqrt(y2); // y = y\u00B2 ^ (p+1)/4\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        throw new Error(\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(\n      readonly r: bigint,\n      readonly s: bigint,\n      readonly recovery?: number\n    ) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const length = mod.getMinHashLength(CURVE.n);\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = ut.isBytes(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK))\n      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b \u2208 [1,q\u22121] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G \u00D7 k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1\u22C5G - U2\u22C5P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const { lowS, prehash } = opts;\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (typeof sg === 'string' || ut.isBytes(sg)) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const { r, s } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if ((error as Error).message === 'PARSE')\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1\u22C5G + u2\u22C5P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: mod.IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n", "import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assertHash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assertExists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assertExists(this);\n    assertBytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass, CurveType } from './abstract/weierstrass.js';\nimport { CHash } from './abstract/utils.js';\n\n// connects noble-curves to noble-hashes\nexport function getHash(hash: CHash) {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n// Same API as @noble/hashes, with ability to create curve with custom hash\ntype CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport function createCurve(curveDef: CurveDef, defHash: CHash) {\n  const create = (hash: CHash) => weierstrass({ ...curveDef, ...getHash(hash) });\n  return Object.freeze({ ...create(defHash), create });\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { ProjPointType as PointType, mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport type { Hex, PrivKey } from './abstract/utils.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * \u221An = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\nexport const secp256k1 = createCurve(\n  {\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'\u22C5G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x \u2265 p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x\u00B3 + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'\u2265n. Ret bytes(d'\u22C5G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'\u22C5G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r \u2265 p.\n    if (!fe(r)) return false;\n    const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s \u2265 n.\n    if (!ge(s)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = s\u22C5G - e\u22C5P\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) \u2260 r.\n  } catch (error) {\n    return false;\n  }\n}\n\nexport const schnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fp,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n  }))();\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fp.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n", "import { schnorr } from \"@noble/curves/secp256k1\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport type { NostrEvent } from \"./nostr\";\n\nconst utf8Encoder = new TextEncoder();\n\n// verifies the signature of the Nostr event\nexport const verifyEventSig = (ev: NostrEvent): boolean => {\n  const serializedEv = JSON.stringify([0, ev.pubkey, ev.created_at, ev.kind, ev.tags, ev.content]);\n  const evHash = bytesToHex(sha256(utf8Encoder.encode(serializedEv)));\n  return schnorr.verify(ev.sig, evHash, ev.pubkey);\n};\n", "type BasicLogLevel = \"verbose\" | \"info\" | \"warn\" | \"error\";\nexport type LogLevel = BasicLogLevel | \"all\" | \"none\";\n\nconst scoreForlogLevel = {\n  all: 0,\n  verbose: 10,\n  info: 20,\n  warn: 30,\n  error: 40,\n  none: 50,\n} satisfies Record<LogLevel, number>;\n\nconst logFnForlogLevel = {\n  verbose: console.debug,\n  info: console.info,\n  warn: console.warn,\n  error: console.error,\n} satisfies Record<BasicLogLevel, typeof console.log>;\n\n/**\n * Logger for debug logs.\n */\nexport class DebugLogger {\n  #minLevel: LogLevel;\n  #prefix: string;\n  #renderedPrefix: string;\n\n  /**\n   * Instantiates a logger.\n   *\n   * @param minLevel minimum log level\n   * @param prefix   prefix for log lines from this logger (optional)\n   */\n  public constructor(minLevel: LogLevel, prefix?: string) {\n    this.#minLevel = minLevel;\n    this.#prefix = prefix ?? \"\";\n    this.#renderedPrefix = prefix ? `[${prefix}]` : \"\";\n  }\n\n  /**\n   * Derives a sub-logger from this logger.\n   *\n   * Prefix of new logger will inherit prefix of this logger, and `subPrefix` will be appended to it.\n   */\n  public subLogger(subPrefix: string): DebugLogger {\n    return this.#prefix\n      ? new DebugLogger(this.#minLevel, `${this.#prefix}:${subPrefix}`)\n      : new DebugLogger(this.#minLevel, subPrefix);\n  }\n\n  /**\n   * Emits log with the specified level.\n   */\n  public log(lv: BasicLogLevel, msg: unknown, ...optionalParams: unknown[]) {\n    if (scoreForlogLevel[lv] < scoreForlogLevel[this.#minLevel]) {\n      return;\n    }\n    this.#renderedPrefix\n      ? logFnForlogLevel[lv](`${this.#renderedPrefix} ${msg}`, ...optionalParams)\n      : logFnForlogLevel[lv](msg, ...optionalParams);\n  }\n}\n", "import { LogLevel } from \"./debugLogger\";\nimport type { Filter, NostrEvent } from \"./nostr\";\n\nexport type EnsureRelaysOptions = {\n  connectTimeoutMs: number;\n};\n\nexport type FetchTillEoseOptions = {\n  subId?: string;\n  skipVerification: boolean;\n  skipFilterMatching: boolean;\n  connectTimeoutMs: number;\n  abortSubBeforeEoseTimeoutMs: number;\n  abortSignal: AbortSignal | undefined;\n};\n\n/**\n * Set of APIs to fetch past events from nostr relays.\n *\n * `NostrFetcher` implements its functions on top of this.\n */\nexport interface NostrFetcherBackend {\n  /**\n   * Ensures connections to the relays prior to an event subscription.\n   *\n   * Returns URLs of relays *successfully connected to*.\n   *\n   * It should *normalize* the passed `relayUrls` before establishing connections to relays.\n   *\n   * Hint:\n   * You should make use of the function `normalizeRelayUrlSet` from `@nostr-fetch/kernel/utils` to normalize a set of relay URLs.\n   *\n   */\n  ensureRelays(relayUrls: string[], options: EnsureRelaysOptions): Promise<string[]>;\n\n  /**\n   * Fetches Nostr events matching `filters` from the relay specified by `relayUrl` until EOSE.\n   *\n   * The result is an `AsyncIterable` of Nostr events.\n   * You can think that it's an asynchronous channel which conveys events.\n   * The channel will be closed once EOSE is reached.\n   *\n   * If one of the following situations occurs, it is regarded as \"failure\".\n   * In such a case, it should throw `FetchTillEoseFailedSignal`.\n   *\n   * - It couldn't establish connection to the relay\n   * - Received a NOTICE message during the fetch\n   * - A WebSocket error occurred during the fetch\n   *\n   *\n   * If the fetch was aborted (due to AbortController or auto abortion timer), it should throw `FetchTillEoseAbortedSignal`.\n   *\n   * Hint:\n   * You can make use of a `Channel` to convert \"push\" style code (bunch of event listers) to `AsyncIterable`.\n   */\n  fetchTillEose(\n    relayUrl: string,\n    filter: Filter,\n    options: FetchTillEoseOptions,\n  ): AsyncIterable<NostrEvent>;\n\n  /**\n   * Cleans up all the internal states of the fetcher.\n   */\n  shutdown(): void;\n}\n\n/**\n * Error type signaling that `NostrFetcherBackend#fetchTillEose()` failed\n * (connection was not established / NOTICE received / WebSocket error occurred)\n */\nexport class FetchTillEoseFailedSignal extends Error {\n  static {\n    this.prototype.name = \"FetchTillEoseFailedSignal\";\n  }\n}\n\n/**\n * Error type signaling that `NostrFetcherBackend#fetchTillEose()` is aborted (due to AbortController or auto abortion)\n */\nexport class FetchTillEoseAbortedSignal extends Error {\n  static {\n    this.prototype.name = \"FetchTillEoseAbortedSignal\";\n  }\n}\n\n/**\n * Check if `err` is {@linkcode FetchTillEoseFailedSignal}.\n *\n * Note that you can't check that using `instanceof` operator.\n */\nexport const isFetchTillEoseFailedSignal = (err: unknown): err is FetchTillEoseFailedSignal =>\n  err instanceof Error && err.name === \"FetchTillEoseFailedSignal\";\n\n/**\n * Check if `err` is {@linkcode FetchTillEoseAbortedSignal}.\n *\n * Note that you can't check that using `instanceof` operator.\n */\nexport const isFetchTillEoseAbortedSignal = (err: unknown): err is FetchTillEoseAbortedSignal =>\n  err instanceof Error && err.name === \"FetchTillEoseAbortedSignal\";\n\n/**\n * Common options for `NostrFetcher` and all `NostrFetcherBackend` implementations.\n */\nexport type NostrFetcherCommonOptions = {\n  minLogLevel?: LogLevel;\n};\n\n/**\n * Default values of `NostrFetcherCommonOptions`.\n */\nexport const defaultFetcherCommonOptions: Required<NostrFetcherCommonOptions> = {\n  minLogLevel: \"warn\",\n};\n\n/**\n * Type of initializer functions of `NostrFetcherBackend`s.  Takes `NostrFetcherCommonOptions` and initialize a `NostrFetcherBackend` impl.\n *\n * A \"relay pool adapter\" should return initializer function of this type.\n */\nexport type NostrFetcherBackendInitializer = (\n  commonOpts: Required<NostrFetcherCommonOptions>,\n) => NostrFetcherBackend;\n", "/**\n * Current unxitime in milliseconds.\n */\nexport const currUnixtimeMilli = (now = new Date()): number => now.getTime();\n\n/**\n * Current unixtime in seconds.\n */\nexport const currUnixtimeSec = (now = new Date()): number =>\n  Math.floor(currUnixtimeMilli(now) / 1000);\n\n// borrowed from nostr-tools (https://github.com/nbd-wtf/nostr-tools).\n/**\n * Normalizes single URL of relay (WebSocket endpoint).\n * @param urlStr\n * @returns\n */\nexport const normalizeRelayUrl = (urlStr: string): string => {\n  const url = new URL(urlStr);\n\n  url.pathname = url.pathname.replace(/\\/+/g, \"/\");\n  if (url.pathname.endsWith(\"/\")) {\n    url.pathname = url.pathname.slice(0, -1);\n  }\n\n  if (\n    (url.port === \"80\" && url.protocol === \"ws:\") ||\n    (url.port === \"443\" && url.protocol === \"wss:\")\n  ) {\n    url.port = \"\";\n  }\n\n  url.searchParams.sort();\n  url.hash = \"\";\n  return url.toString();\n};\n\nconst dedup = <T>(items: T[]): T[] => {\n  return Array.from(new Set(items));\n};\n\n/**\n * Normalizes all relay URLs, then removes duplications.\n *\n * It also filters out malformed URLs.\n */\nexport const normalizeRelayUrlSet = (relayUrls: string[]): string[] => {\n  return dedup(\n    relayUrls\n      .filter((u) => {\n        try {\n          new URL(u);\n          return true;\n        } catch {\n          return false;\n        }\n      })\n      .map((u) => normalizeRelayUrl(u)),\n  );\n};\n\n/**\n *  Empty AsyncGenerator\n */\n// eslint-disable-next-line require-yield\nexport async function* emptyAsyncGen() {\n  return;\n}\n\n/**\n * Abbreviates strings as:\n * <first `affixLen` chars of `s`> + \":\" + <last `affixLen` chars of `s`>\n *\n * if `s.length` is less than `affixLen * 2` or `affixLen` is not positive, just returns original string.\n */\nexport const abbreviate = (s: string, affixLen: number): string => {\n  if (s.length <= affixLen * 2 || affixLen <= 0) {\n    return s;\n  }\n  const len = s.length;\n  return `${s.slice(0, affixLen)}:${s.slice(len - affixLen)}`;\n};\n\n/**\n * Attaches timeout to the `promise`.\n *\n * If the `promise` is not settled by the time limit, returned promise rejects with the error which has the specified message.\n */\nexport const withTimeout = async <T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  msgOnTimeout: string,\n): Promise<T> => {\n  let timer: NodeJS.Timeout;\n  const timeout = new Promise<never>((_, reject) => {\n    timer = setTimeout(() => reject(Error(msgOnTimeout)), timeoutMs);\n  });\n\n  return Promise.race([promise.finally(() => clearTimeout(timer)), timeout]);\n};\n", "/**\n * The data structure of Nostr event.\n */\nexport type NostrEvent = {\n  id: string;\n  pubkey: string;\n  created_at: number;\n  kind: number;\n  tags: string[][];\n  content: string;\n  sig: string;\n};\n\n/**\n * Standardized Nostr event kinds.\n * cf. https://github.com/nostr-protocol/nips#event-kinds\n */\nexport const eventKind = {\n  metadata: 0,\n  text: 1,\n  recommendRelay: 2,\n  contacts: 3,\n  encryptedDirectMessage: 4,\n  eventDeletion: 5,\n  repost: 6,\n  reaction: 7,\n  badgeAward: 8,\n  genericRepost: 16,\n  channelCreation: 40,\n  channelMetadata: 41,\n  channelMessage: 42,\n  channelHideMessage: 43,\n  channelMuteUser: 44,\n  fileMetadata: 1063,\n  liveChatMessage: 1311,\n  report: 1984,\n  label: 1985,\n  communityPostApproval: 4550,\n  zapRequest: 9734,\n  zap: 9735,\n  muteList: 10000,\n  pinList: 10001,\n  relayList: 10002,\n  walletInfo: 13194,\n  clientAuth: 22242,\n  walletRequest: 23194,\n  walletResponse: 23195,\n  nostrConnect: 24133,\n  httpAuth: 27235,\n  categorizedPeopleList: 30000,\n  categorizedBookmarkList: 30001,\n  profileBadges: 30008,\n  badgeDefinition: 30009,\n  marketplaceStall: 30017,\n  marketplaceProduct: 30018,\n  article: 30023,\n  draftArticle: 30024,\n  appSpecificData: 30078,\n  liveEvent: 30311,\n  classifiedListing: 30402,\n  draftClassifiedListing: 30403,\n  dateBasedCalendarEvent: 31922,\n  timeBasedCalendarEvent: 31923,\n  calendar: 31924,\n  calendarEventRsvp: 31925,\n  handlerRecommendation: 31989,\n  handlerInformation: 31990,\n  communityDefinition: 34550,\n} as const;\n\n/**\n * Standardized single letter tag names.\n * cf. https://github.com/nostr-protocol/nips#standardized-tags\n */\ntype SingleLetterTags = \"a\" | \"d\" | \"e\" | \"g\" | \"i\" | \"k\" | \"l\" | \"L\" | \"m\" | \"p\" | \"r\" | \"t\" | \"x\";\n\n/**\n * Keys of filter props for tag queries.\n */\ntype TagQueryKey = `#${SingleLetterTags}`;\n\n/**\n * Filter for Nostr event subscription.\n */\nexport type Filter = {\n  ids?: string[];\n  kinds?: number[];\n  authors?: string[];\n  since?: number;\n  until?: number;\n  limit?: number;\n  search?: string;\n} & {\n  [tag in TagQueryKey]?: string[];\n};\n\n// client to relay messages\ntype C2RReq = [type: \"REQ\", subId: string, ...filters: Filter[]];\ntype C2RClose = [type: \"CLOSE\", subId: string];\n\nexport type C2RMessage = C2RReq | C2RClose;\nexport type C2RMessageType = C2RMessage[0];\n\n// relay to client messages\ntype R2CEvent = [type: \"EVENT\", subId: string, event: NostrEvent];\ntype R2CEose = [type: \"EOSE\", subId: string];\ntype R2CClosed = [type: \"CLOSED\", subId: string, message: string];\ntype R2CNotice = [type: \"NOTICE\", notice: string];\n\nexport type R2CMessage = R2CEvent | R2CEose | R2CClosed | R2CNotice;\nexport type R2CMessageType = R2CMessage[0];\n\nexport type R2CSubMessage = R2CEvent | R2CEose;\nexport type R2CSubMessageType = R2CSubMessage[0];\n\nconst supportedR2CMsgTypes: R2CMessageType[] = [\"EVENT\", \"EOSE\", \"CLOSED\", \"NOTICE\"];\nconst isSupportedR2CMsgType = (s: string): s is R2CMessageType =>\n  (supportedR2CMsgTypes as string[]).includes(s);\n\nexport const parseR2CMessage = (rawMsg: string): R2CMessage | undefined => {\n  let parsed: unknown;\n  try {\n    parsed = JSON.parse(rawMsg) as unknown;\n  } catch (err) {\n    console.error(\"failed to parse R2C message as JSON:\", err);\n    return undefined;\n  }\n\n  if (!Array.isArray(parsed) || parsed.length === 0 || typeof parsed[0] !== \"string\") {\n    console.error(\"malformed R2C message\");\n    return undefined;\n  }\n\n  const msgType = parsed[0] as string;\n  if (!isSupportedR2CMsgType(msgType)) {\n    console.error(\"unsupported R2C message type:\", parsed[0]);\n    return undefined;\n  }\n  switch (msgType) {\n    case \"EVENT\": {\n      if (parsed.length !== 3) {\n        console.error(\"malformed R2C EVENT\");\n        return undefined;\n      }\n      const [, subId, ev] = parsed;\n      if (typeof subId !== \"string\" || typeof ev !== \"object\" || ev === null) {\n        console.error(\"malformed R2C EVENT\");\n        return undefined;\n      }\n      if (!validateEvent(ev)) {\n        console.error(\"malformed event in R2C EVENT\");\n        return undefined;\n      }\n      return parsed as R2CEvent;\n    }\n    case \"EOSE\": {\n      if (parsed.length !== 2 || typeof parsed[1] !== \"string\") {\n        console.error(\"malformed R2C EOSE\");\n        return undefined;\n      }\n      return parsed as R2CEose;\n    }\n    case \"CLOSED\": {\n      if (parsed.length !== 3 || typeof parsed[1] !== \"string\" || typeof parsed[2] !== \"string\") {\n        console.error(\"malformed R2C CLOSED\");\n        return undefined;\n      }\n      return parsed as R2CClosed;\n    }\n    case \"NOTICE\": {\n      if (parsed.length !== 2) {\n        console.error(\"malformed R2C NOTICE\");\n        return undefined;\n      }\n      return parsed as R2CNotice;\n    }\n    default:\n      return undefined;\n  }\n};\n\n// schema validation for Nostr events\nexport const validateEvent = (rawEv: Record<string, unknown>): rawEv is NostrEvent => {\n  // id: 32-bytes lowercase hex-encoded sha256\n  if (!(\"id\" in rawEv) || typeof rawEv[\"id\"] !== \"string\" || !is32BytesHexStr(rawEv[\"id\"])) {\n    return false;\n  }\n\n  // pubkey: 32-bytes lowercase hex-encoded public key\n  if (\n    !(\"pubkey\" in rawEv) ||\n    typeof rawEv[\"pubkey\"] !== \"string\" ||\n    !is32BytesHexStr(rawEv[\"pubkey\"])\n  ) {\n    return false;\n  }\n\n  // created_at: unix timestamp in seconds\n  if (!(\"created_at\" in rawEv) || typeof rawEv[\"created_at\"] !== \"number\") {\n    return false;\n  }\n\n  // kind: integer\n  if (!(\"kind\" in rawEv) || typeof rawEv[\"kind\"] !== \"number\") {\n    return false;\n  }\n\n  // tags: array of arrays of non-null strings\n  if (!(\"tags\" in rawEv) || !Array.isArray(rawEv[\"tags\"])) {\n    return false;\n  }\n  if (rawEv[\"tags\"].some((tag) => !Array.isArray(tag) || tag.some((e) => typeof e !== \"string\"))) {\n    return false;\n  }\n\n  // content: string\n  if (!(\"content\" in rawEv) || typeof rawEv[\"content\"] !== \"string\") {\n    return false;\n  }\n\n  // sig: 64-bytes hex of the signature\n  if (!(\"sig\" in rawEv) || typeof rawEv[\"sig\"] !== \"string\" || !is64BytesHexStr(rawEv[\"sig\"])) {\n    return false;\n  }\n\n  return true;\n};\n\nconst is32BytesHexStr = (s: string): boolean => {\n  return /^[a-f0-9]{64}$/.test(s);\n};\n\nconst is64BytesHexStr = (s: string): boolean => {\n  return /^[a-f0-9]{128}$/.test(s);\n};\n\ntype CompiledFilter = {\n  ids: Set<string> | undefined;\n  kinds: Set<number> | undefined;\n  authors: Set<string> | undefined;\n  tags: [string, Set<string>][];\n  since: number | undefined;\n  until: number | undefined;\n};\n\nconst compileFilter = (f: Filter): CompiledFilter => {\n  const ids = f.ids ? new Set(f.ids) : undefined;\n  const kinds = f.kinds ? new Set(f.kinds) : undefined;\n  const authors = f.authors ? new Set(f.authors) : undefined;\n\n  const tags: [string, Set<string>][] = [];\n  for (const k of Object.keys(f)) {\n    if (k.startsWith(\"#\") && k.length === 2) {\n      tags.push([k.charAt(1), new Set(f[k as TagQueryKey] ?? [])] as [string, Set<string>]);\n    }\n  }\n  return { ids, kinds, authors, tags, since: f.since, until: f.until };\n};\n\nconst getTagValuesByName = (ev: NostrEvent, tagName: string): string[] =>\n  ev.tags.filter((t) => t[0] === tagName).map((t) => t[1] ?? \"\");\n\nconst matchWithCompiledFilter = (f: CompiledFilter, ev: NostrEvent): boolean => {\n  if (f.ids !== undefined && !f.ids.has(ev.id)) {\n    return false;\n  }\n  if (f.kinds !== undefined && !f.kinds.has(ev.kind)) {\n    return false;\n  }\n  if (f.authors !== undefined && !f.authors.has(ev.pubkey)) {\n    return false;\n  }\n  if (f.since !== undefined && ev.created_at < f.since) {\n    return false;\n  }\n  if (f.until !== undefined && ev.created_at > f.until) {\n    return false;\n  }\n  const tagMatched = f.tags.every(([tagName, queryVals]) => {\n    const tagVals = getTagValuesByName(ev, tagName);\n    if (tagVals.length === 0) {\n      // required tag is missing\n      return false;\n    }\n    return tagVals.some((e) => queryVals.has(e));\n  });\n  return tagMatched;\n};\n\nexport class FilterMatcher {\n  #filters: CompiledFilter[];\n\n  constructor(filters: Filter[]) {\n    this.#filters = filters.map(compileFilter);\n  }\n\n  public match(ev: NostrEvent): boolean {\n    return this.#filters.some((f) => matchWithCompiledFilter(f, ev));\n  }\n}\n\n/* Check Relay's Capabilities */\n/**\n * Queries supported NIP numbers of the given relay.\n */\nexport const querySupportedNips = async (relayUrl: string): Promise<Set<number>> => {\n  try {\n    const httpUrl = toHttpUrl(relayUrl);\n\n    const abortCtrl = new AbortController();\n    const abortTimer = setTimeout(() => {\n      abortCtrl.abort();\n    }, 5000);\n\n    const resp = await fetch(httpUrl, {\n      headers: { Accept: \"application/nostr+json\" },\n      signal: abortCtrl.signal,\n    });\n    clearTimeout(abortTimer);\n\n    if (!resp.ok) {\n      console.error(\"relay information response is not ok\");\n      return new Set();\n    }\n\n    const relayInfo = await resp.json();\n    if (!relayInfoHasSupportedNips(relayInfo)) {\n      console.error(\"relay information document doesn't have proper 'supported_nips' property\");\n      return new Set();\n    }\n    return new Set(relayInfo.supported_nips);\n  } catch (err) {\n    console.error(err);\n    return new Set();\n  }\n};\n\nconst toHttpUrl = (url: string): string => {\n  const u = new URL(url);\n  switch (u.protocol) {\n    case \"wss:\":\n      u.protocol = \"https:\";\n      break;\n    case \"ws:\":\n      u.protocol = \"http:\";\n      break;\n  }\n  return u.toString();\n};\n\ntype RelayInfoWithSupportedNips = {\n  supported_nips: number[];\n};\n\nconst relayInfoHasSupportedNips = (relayInfo: unknown): relayInfo is RelayInfoWithSupportedNips =>\n  typeof relayInfo === \"object\" &&\n  relayInfo !== null &&\n  \"supported_nips\" in relayInfo &&\n  Array.isArray(relayInfo.supported_nips) &&\n  (relayInfo.supported_nips.length === 0 ||\n    relayInfo.supported_nips.every((e: unknown) => typeof e === \"number\"));\n\n/* Utilities */\n// utility to generate a random subscription ID\nexport const generateSubId = () => {\n  return Date.now().toString() + Math.random().toString(32).substring(2, 4);\n};\n\nconst reqErrRegexps = [\n  /^too many concurrent REQs$/i,\n  /^Subscription rejected/i,\n  /^invalid:(.*)must (contain|be) less than or equal to/i,\n  /^message too large$/i,\n  /^Maximum concurrent subscription count reached$/i,\n];\n\n/**\n * Checks if the NOTICE message seems to have to do with REQs by fetcher.\n *\n * Considers following relay implementations:\n *\n * - strfry\n * - nostream\n * - nostr-rs-relay\n * - relayer\n */\nexport const isNoticeForReqError = (notice: string): boolean =>\n  reqErrRegexps.some((r) => r.test(notice));\n", "import { verifyEventSig } from \"@nostr-fetch/kernel/crypto\";\nimport type { C2RMessage, Filter, NostrEvent } from \"@nostr-fetch/kernel/nostr\";\nimport { FilterMatcher, generateSubId, parseR2CMessage } from \"@nostr-fetch/kernel/nostr\";\nimport { WebSocketReadyState } from \"@nostr-fetch/kernel/webSocket\";\n\ntype Callback<E> = E extends void ? () => void : (ev: E) => void;\n\nexport interface Relay {\n  url: string;\n  wsReadyState: number;\n\n  connect(): Promise<Relay>;\n  close(): void;\n  prepareSub(filters: Filter[], options: SubscriptionOptions): Subscription;\n\n  on<E extends RelayEventTypes>(type: E, cb: RelayEventCbTypes[E]): void;\n  off<E extends RelayEventTypes>(type: E, cb: RelayEventCbTypes[E]): void;\n}\n\nexport type RelayOptions = {\n  connectTimeoutMs: number;\n};\n\nexport const initRelay = (relayUrl: string, options: RelayOptions): Relay => {\n  return new RelayImpl(relayUrl, options);\n};\n\nexport type WSCloseEvent = {\n  code: number;\n  reason: string;\n  wasClean: boolean | undefined; // optional since websocket-polyfill's CloseEvent doesn't have it\n};\n\nexport type RelayConnectCb = Callback<void>;\nexport type RelayDisconnectCb = Callback<WSCloseEvent | undefined>;\nexport type RelayNoticeCb = Callback<string>;\nexport type RelayErrorCb = Callback<void>;\n\nexport type RelayEventCbTypes = {\n  connect: RelayConnectCb;\n  disconnect: RelayDisconnectCb;\n  notice: RelayNoticeCb;\n  error: RelayErrorCb;\n};\n\nexport type RelayEventTypes = keyof RelayEventCbTypes;\n\ntype RelayListenersTable = {\n  [E in RelayEventTypes]: Set<RelayEventCbTypes[E]>;\n};\n\nclass RelayImpl implements Relay {\n  #relayUrl: string;\n  #ws: WebSocket | undefined;\n\n  #options: Required<RelayOptions>;\n\n  #listeners: RelayListenersTable = {\n    connect: new Set(),\n    disconnect: new Set(),\n    notice: new Set(),\n    error: new Set(),\n  };\n  #subscriptions: Map<string, RelaySubscription> = new Map();\n\n  #msgQueue: string[] = [];\n  #handleMsgsInterval: NodeJS.Timeout | undefined;\n\n  constructor(relayUrl: string, options: RelayOptions) {\n    this.#relayUrl = relayUrl;\n    this.#options = options;\n  }\n\n  public get url(): string {\n    return this.#relayUrl;\n  }\n\n  public get wsReadyState(): number {\n    return this.#ws?.readyState ?? WebSocketReadyState.CONNECTING;\n  }\n\n  private forwardToSub(subId: string, forwardFn: (sub: RelaySubscription) => void) {\n    const targSub = this.#subscriptions.get(subId);\n    if (targSub !== undefined) {\n      forwardFn(targSub);\n    }\n  }\n\n  private handleMsgs() {\n    if (this.#msgQueue.length === 0) {\n      clearInterval(this.#handleMsgsInterval);\n      this.#handleMsgsInterval = undefined;\n      return;\n    }\n\n    const dispatchStartedAt = performance.now();\n\n    while (this.#msgQueue.length > 0 && performance.now() - dispatchStartedAt < 5.0) {\n      const rawMsg = this.#msgQueue.shift() as string;\n      const parsed = parseR2CMessage(rawMsg);\n      if (parsed === undefined) {\n        continue;\n      }\n\n      switch (parsed[0]) {\n        case \"EVENT\": {\n          const [, subId, ev] = parsed;\n          this.forwardToSub(subId, (sub) => sub._forwardEvent(ev));\n          break;\n        }\n        case \"EOSE\": {\n          const [, subId] = parsed;\n          this.forwardToSub(subId, (sub) => sub._forwardEose());\n          break;\n        }\n        case \"CLOSED\": {\n          const [, subId, msg] = parsed;\n          this.forwardToSub(subId, (sub) => sub._forwardClosed(msg));\n          break;\n        }\n        case \"NOTICE\": {\n          const [, notice] = parsed;\n          this.#listeners.notice.forEach((cb) => cb(notice));\n          break;\n        }\n      }\n    }\n  }\n\n  public async connect(): Promise<Relay> {\n    return new Promise<Relay>((resolve, reject) => {\n      let isTimedout = false;\n      const timeout = setTimeout(() => {\n        isTimedout = true;\n        reject(Error(`attempt to connect to the relay '${this.#relayUrl}' timed out`));\n      }, this.#options.connectTimeoutMs);\n\n      const ws = new WebSocket(this.#relayUrl);\n\n      ws.onopen = () => {\n        if (!isTimedout) {\n          this.#listeners.connect.forEach((cb) => cb());\n          this.#ws = ws;\n\n          // set error listeners after the connection opened successfully\n          ws.onerror = () => {\n            this.#listeners.error.forEach((cb) => cb());\n          };\n\n          resolve(this);\n\n          clearTimeout(timeout);\n        }\n      };\n\n      // error listeners are *not* activated while attempt to connect is in progress\n      ws.onerror = () => {\n        reject(Error(\"WebSocket error\"));\n\n        clearTimeout(timeout);\n      };\n\n      ws.onclose = (e: WSCloseEvent) => {\n        const reducted = {\n          code: e.code,\n          reason: e.reason,\n          wasClean: e.wasClean,\n        };\n        this.#listeners.disconnect.forEach((cb) => cb(reducted));\n      };\n\n      ws.onmessage = (e: MessageEvent) => {\n        this.#msgQueue.push(e.data);\n        if (this.#handleMsgsInterval === undefined) {\n          this.#handleMsgsInterval = setInterval(() => this.handleMsgs(), 0);\n        }\n      };\n    });\n  }\n\n  public close() {\n    if (this.#ws !== undefined) {\n      this.#ws.close();\n    }\n  }\n\n  public prepareSub(filters: Filter[], options: SubscriptionOptions): Subscription {\n    const subId = options.subId ?? generateSubId();\n    const sub = new RelaySubscription(this, subId, filters, options);\n    this.#subscriptions.set(subId, sub);\n\n    return sub;\n  }\n\n  _removeSub(subId: string) {\n    this.#subscriptions.delete(subId);\n  }\n\n  public on<E extends RelayEventTypes>(type: E, cb: RelayEventCbTypes[E]) {\n    this.#listeners[type].add(cb);\n  }\n\n  public off<E extends RelayEventTypes>(type: E, cb: RelayEventCbTypes[E]) {\n    this.#listeners[type].delete(cb);\n  }\n\n  _sendC2RMessage(msg: C2RMessage) {\n    if (this.#ws === undefined || this.#ws.readyState !== WebSocketReadyState.OPEN) {\n      throw Error(\"not connected to the relay\");\n    }\n    this.#ws.send(JSON.stringify(msg));\n  }\n}\n\ntype EoseEventPayload = {\n  aborted: boolean;\n};\n\nexport type SubEventCb = Callback<NostrEvent>;\nexport type SubEoseCb = Callback<EoseEventPayload>;\nexport type SubClosedCb = Callback<string>;\n\nexport type SubEventCbTypes = {\n  event: SubEventCb;\n  eose: SubEoseCb;\n  closed: SubClosedCb;\n};\n\nexport type SubEventTypes = keyof SubEventCbTypes;\n\nexport interface Subscription {\n  subId: string;\n  req(): void;\n  close(): void;\n  on<E extends SubEventTypes>(type: E, cb: SubEventCbTypes[E]): void;\n  off<E extends SubEventTypes>(type: E, cb: SubEventCbTypes[E]): void;\n}\n\nexport interface SubscriptionOptions {\n  subId?: string;\n  skipVerification: boolean;\n  skipFilterMatching: boolean;\n  abortSubBeforeEoseTimeoutMs: number;\n}\n\ntype SubListenersTable = {\n  [E in SubEventTypes]: Set<SubEventCbTypes[E]>;\n};\n\nclass RelaySubscription implements Subscription {\n  #relay: RelayImpl;\n  #subId: string;\n  #filters: Filter[];\n  #filterMatcher: FilterMatcher;\n  #options: SubscriptionOptions;\n\n  #listeners: SubListenersTable = {\n    event: new Set(),\n    eose: new Set(),\n    closed: new Set(),\n  };\n\n  #abortSubTimer: NodeJS.Timeout | undefined;\n\n  constructor(relay: RelayImpl, subId: string, filters: Filter[], options: SubscriptionOptions) {\n    this.#relay = relay;\n    this.#subId = subId;\n    this.#filters = filters;\n    this.#filterMatcher = new FilterMatcher(filters);\n    this.#options = options;\n  }\n\n  public get subId(): string {\n    return this.#subId;\n  }\n\n  public req() {\n    this.#relay._sendC2RMessage([\"REQ\", this.#subId, ...this.#filters]);\n    this.#resetAbortSubTimer();\n  }\n\n  public close() {\n    this.#clearListeners();\n    this.#relay._removeSub(this.#subId);\n\n    this.#relay._sendC2RMessage([\"CLOSE\", this.#subId]);\n  }\n\n  public on<E extends SubEventTypes>(type: E, cb: SubEventCbTypes[E]) {\n    this.#listeners[type].add(cb);\n  }\n\n  public off<E extends SubEventTypes>(type: E, cb: SubEventCbTypes[E]) {\n    this.#listeners[type].delete(cb);\n  }\n\n  #clearListeners() {\n    for (const s of Object.values(this.#listeners)) {\n      s.clear();\n    }\n  }\n\n  #resetAbortSubTimer() {\n    if (this.#abortSubTimer !== undefined) {\n      clearTimeout(this.#abortSubTimer);\n      this.#abortSubTimer = undefined;\n    }\n\n    this.#abortSubTimer = setTimeout(() => {\n      this.#listeners.eose.forEach((cb) => cb({ aborted: true }));\n    }, this.#options.abortSubBeforeEoseTimeoutMs);\n  }\n\n  _forwardEvent(ev: NostrEvent) {\n    this.#resetAbortSubTimer();\n\n    if (!this.#options.skipVerification && !verifyEventSig(ev)) {\n      return;\n    }\n    if (!this.#options.skipFilterMatching && !this.#filterMatcher.match(ev)) {\n      return;\n    }\n    this.#listeners.event.forEach((cb) => cb(ev));\n  }\n\n  _forwardEose() {\n    if (this.#abortSubTimer !== undefined) {\n      clearTimeout(this.#abortSubTimer);\n    }\n    this.#listeners.eose.forEach((cb) => cb({ aborted: false }));\n  }\n\n  _forwardClosed(msg: string) {\n    this.#listeners.closed.forEach((cb) => cb(msg));\n\n    // subscription has been closed by the relay -> clean up things\n    this.#clearListeners();\n    this.#relay._removeSub(this.#subId);\n  }\n}\n", "import type { Relay, RelayOptions } from \"./relay\";\nimport { initRelay } from \"./relay\";\n\nimport { Deferred } from \"@nostr-fetch/kernel/channel\";\nimport { DebugLogger, LogLevel } from \"@nostr-fetch/kernel/debugLogger\";\nimport {\n  currUnixtimeMilli,\n  normalizeRelayUrl,\n  normalizeRelayUrlSet,\n} from \"@nostr-fetch/kernel/utils\";\nimport { WebSocketReadyState } from \"@nostr-fetch/kernel/webSocket\";\n\n// [NIP-01](https://github.com/nostr-protocol/nips/blob/master/01.md#other-notes) says:\n// > When a websocket is closed by the relay with a status code 4000 that means the client shouldn't try to connect again.\nconst CLOSE_CODE_RELAY_NOT_RECONNECTABLE = 4000;\n\nexport interface RelayPool {\n  ensureRelays(relayUrls: string[], relayOpts: RelayOptions): Promise<string[]>;\n  ensureSingleRelay(relayUrl: string, relayOpts: RelayOptions): Promise<Relay | undefined>;\n  shutdown(): void;\n}\n\nexport type RelayPoolOptions = {\n  minLogLevel: LogLevel;\n};\n\nexport const initRelayPool = (opts: RelayPoolOptions): RelayPool => {\n  return new RelayPoolImpl(opts);\n};\n\ntype AliveRelay = {\n  state: \"alive\";\n  relayUrl: string;\n  relay: Relay;\n};\ntype ConnectingRelay = {\n  state: \"connecting\";\n  relayUrl: string;\n  wait: Promise<void>;\n};\ntype ConnectFailedRelay = {\n  state: \"connectFailed\";\n  relayUrl: string;\n  failedAt: number; // unixtime(ms)\n};\ntype DisconnectedRelay = {\n  state: \"disconnected\";\n  relayUrl: string;\n  reconnectable: boolean;\n};\ntype ManagedRelay = AliveRelay | ConnectingRelay | ConnectFailedRelay | DisconnectedRelay;\n\nconst WATCHDOG_INTERVAL = 30 * 1000;\nconst WATCHDOG_CONN_TIMEOUT = 10 * 1000;\n\nclass RelayPoolImpl implements RelayPool {\n  // keys are **normalized** relay URLs\n  #relays: Map<string, ManagedRelay> = new Map();\n\n  #watchdogTimer: NodeJS.Timeout;\n  #debugLogger: DebugLogger | undefined;\n\n  constructor(options: Required<RelayPoolOptions>) {\n    if (options.minLogLevel !== \"none\") {\n      this.#debugLogger = new DebugLogger(options.minLogLevel);\n    }\n\n    // initiate a watchdog timer for relay connections\n    this.#watchdogTimer = setInterval(() => {\n      this.#debugLogger?.log(\"info\", \"watchdog started\");\n\n      const rurls = Array.from(this.#relays.keys());\n      this.addRelays(rurls, { connectTimeoutMs: WATCHDOG_CONN_TIMEOUT }).then(() => {\n        this.#debugLogger?.log(\"info\", \"watchdog completed\");\n      });\n    }, WATCHDOG_INTERVAL);\n  }\n\n  #relayShouldBeReconnected(relay: ManagedRelay): boolean {\n    return (\n      (relay.state === \"connectFailed\" && currUnixtimeMilli() - relay.failedAt > 30 * 1000) ||\n      (relay.state === \"disconnected\" && relay.reconnectable) ||\n      (relay.state === \"alive\" && relay.relay.wsReadyState === WebSocketReadyState.CLOSED) // is it possible?\n    );\n  }\n\n  // `relayUrls` should be normalized in advance.\n  private async addRelays(relayUrls: string[], relayOpts: RelayOptions): Promise<void> {\n    const relaysToConnect: string[] = [];\n    const waitsForConnect: Promise<void>[] = [];\n\n    for (const rurl of relayUrls) {\n      const r = this.#relays.get(rurl);\n      if (r === undefined || this.#relayShouldBeReconnected(r)) {\n        relaysToConnect.push(rurl);\n      } else if (r.state === \"connecting\") {\n        waitsForConnect.push(r.wait);\n      }\n    }\n\n    await Promise.all([\n      ...relaysToConnect.map(async (rurl): Promise<void> => {\n        const logger = this.#debugLogger?.subLogger(rurl);\n\n        const deferred = new Deferred<void>();\n        try {\n          this.#relays.set(rurl, { state: \"connecting\", relayUrl: rurl, wait: deferred.promise });\n\n          const r = initRelay(rurl, relayOpts);\n          r.on(\"connect\", () => logger?.log(\"info\", `connected`));\n          r.on(\"disconnect\", (ev) => {\n            logger?.log(\"info\", `disconnected: ${JSON.stringify(ev)}`);\n            this.#relays.set(r.url, {\n              state: \"disconnected\",\n              relayUrl: r.url,\n              reconnectable: ev.code !== CLOSE_CODE_RELAY_NOT_RECONNECTABLE,\n            });\n          });\n          r.on(\"error\", () => {\n            logger?.log(\"error\", `WebSocket error`);\n            this.#relays.set(r.url, {\n              state: \"disconnected\",\n              relayUrl: r.url,\n              reconnectable: true,\n            });\n          });\n          r.on(\"notice\", (notice) => logger?.log(\"warn\", `NOTICE: ${notice}`));\n\n          await r.connect();\n          this.#relays.set(rurl, { state: \"alive\", relayUrl: rurl, relay: r });\n        } catch {\n          logger?.log(\"error\", \"failed to connect to the relay\");\n          this.#relays.set(rurl, {\n            state: \"connectFailed\",\n            relayUrl: rurl,\n            failedAt: currUnixtimeMilli(),\n          });\n        } finally {\n          deferred.resolve();\n        }\n      }),\n      ...waitsForConnect,\n    ]);\n  }\n\n  public async ensureRelays(relayUrls: string[], relayOpts: RelayOptions): Promise<string[]> {\n    const normalizedUrls = normalizeRelayUrlSet(relayUrls);\n    await this.addRelays(normalizedUrls, relayOpts);\n\n    const connectedRelays: string[] = [];\n    for (const rurl of normalizedUrls) {\n      const r = this.#relays.get(rurl);\n      if (r !== undefined && r.state === \"alive\") {\n        connectedRelays.push(r.relay.url);\n      }\n    }\n    return connectedRelays;\n  }\n\n  public async ensureSingleRelay(\n    relayUrl: string,\n    relayOpts: RelayOptions,\n  ): Promise<Relay | undefined> {\n    const normalizedUrl = normalizeRelayUrl(relayUrl);\n    await this.addRelays([normalizedUrl], relayOpts);\n\n    const r = this.#relays.get(normalizedUrl);\n    if (r !== undefined && r.state === \"alive\") {\n      return r.relay;\n    }\n    return undefined;\n  }\n\n  /**\n   * Cleans up all the internal states of the fetcher.\n   *\n   * It also closes all the connections to the relays.\n   */\n  public shutdown() {\n    clearInterval(this.#watchdogTimer);\n\n    for (const [, r] of this.#relays) {\n      if (r.state === \"alive\") {\n        r.relay.close();\n      }\n    }\n    this.#relays.clear();\n  }\n}\n", "import { Channel } from \"@nostr-fetch/kernel/channel\";\nimport {\n  FetchTillEoseAbortedSignal,\n  FetchTillEoseFailedSignal,\n  type EnsureRelaysOptions,\n  type FetchTillEoseOptions,\n  type NostrFetcherBackend,\n  type NostrFetcherCommonOptions,\n} from \"@nostr-fetch/kernel/fetcherBackend\";\nimport { isNoticeForReqError, type Filter, type NostrEvent } from \"@nostr-fetch/kernel/nostr\";\n\nimport { DebugLogger } from \"@nostr-fetch/kernel/debugLogger\";\nimport { RelayPool, initRelayPool } from \"./relayPool\";\n\n/**\n * Default implementation of `NostrFetchBackend`.\n */\nexport class DefaultFetcherBackend implements NostrFetcherBackend {\n  #relayPool: RelayPool;\n  #debugLogger: DebugLogger | undefined;\n\n  public constructor(commonOpts: Required<NostrFetcherCommonOptions>) {\n    this.#relayPool = initRelayPool(commonOpts);\n    if (commonOpts.minLogLevel !== \"none\") {\n      this.#debugLogger = new DebugLogger(commonOpts.minLogLevel);\n    }\n  }\n\n  /**\n   * Ensures connections to the relays prior to an event subscription.\n   *\n   * Returns URLs of relays *successfully connected to*.\n   *\n   * It should *normalize* the passed `relayUrls` before establishing connections to relays.\n   */\n  public async ensureRelays(relayUrls: string[], options: EnsureRelaysOptions): Promise<string[]> {\n    return this.#relayPool.ensureRelays(relayUrls, options);\n  }\n\n  /**\n   * Closes all the connections to relays and clean up the internal relay pool.\n   */\n  public shutdown(): void {\n    this.#relayPool.shutdown();\n  }\n\n  /**\n   * Fetches Nostr events matching `filters` from the relay specified by `relayUrl` until EOSE.\n   *\n   * The result is an `AsyncIterable` of Nostr events.\n   * You can think that it's an asynchronous channel which conveys events.\n   * The channel will be closed once EOSE is reached.\n   *\n   * If one of the following situations occurs, it is regarded as \"failure\".\n   * In such a case, it should throw `FetchTillEoseFailedSignal`.\n   *\n   * - It couldn't establish connection to the relay\n   * - Received a NOTICE message during the fetch\n   * - A WebSocket error occurred during the fetch\n   *\n   * If the fetch was aborted (due to AbortController or auto abortion timer), it should throw `FetchTillEoseAbortedSignal`.\n   */\n  public async *fetchTillEose(\n    relayUrl: string,\n    filter: Filter,\n    options: FetchTillEoseOptions,\n  ): AsyncIterable<NostrEvent> {\n    const logger = this.#debugLogger?.subLogger(relayUrl);\n\n    const relay = await this.#relayPool.ensureSingleRelay(relayUrl, options);\n    if (relay === undefined) {\n      throw new FetchTillEoseFailedSignal(\"failed to ensure connection to the relay\");\n    }\n\n    const [tx, chIter] = Channel.make<NostrEvent>();\n\n    // relay error handlings\n    const onNotice = (n: string) => {\n      // ignore if the message seems to have nothing to do with REQs by fetcher\n      if (!isNoticeForReqError(n)) {\n        return;\n      }\n\n      try {\n        sub.close();\n      } catch (err) {\n        logger?.log(\"error\", `failed to close subscription (id: ${sub.subId}): ${err}`);\n      }\n      removeRelayListeners();\n      tx.error(new FetchTillEoseFailedSignal(`NOTICE: ${n}`));\n    };\n    const onError = () => {\n      // WebSocket error closes the connection, so calling close() is meaningless\n      removeRelayListeners();\n      tx.error(new FetchTillEoseFailedSignal(\"WebSocket error\"));\n    };\n    const removeRelayListeners = () => {\n      relay.off(\"notice\", onNotice);\n      relay.off(\"error\", onError);\n    };\n\n    relay.on(\"notice\", onNotice);\n    relay.on(\"error\", onError);\n\n    // prepare a subscription\n    const sub = relay.prepareSub([filter], options);\n\n    // handle subscription events\n    sub.on(\"event\", (ev: NostrEvent) => {\n      tx.send(ev);\n    });\n    sub.on(\"eose\", ({ aborted }) => {\n      closeSub();\n      if (aborted) {\n        tx.error(\n          new FetchTillEoseAbortedSignal(\n            `subscription (id: ${sub.subId}) aborted before EOSE due to timeout`,\n          ),\n        );\n      } else {\n        tx.close();\n      }\n    });\n    sub.on(\"closed\", (msg) => {\n      tx.error(\n        new FetchTillEoseFailedSignal(`subscription (id: ${sub.subId}) closed by relay: ${msg}`),\n      );\n    });\n\n    // common process to close subscription\n    const closeSub = () => {\n      try {\n        sub.close();\n      } catch (err) {\n        logger?.log(\"error\", `failed to close subscription (id: ${sub.subId}): ${err}`);\n      }\n      removeRelayListeners();\n      logger?.log(\"verbose\", `CLOSE: subId=${options.subId ?? \"<auto>\"}`);\n    };\n\n    // start the subscription\n    logger?.log(\"verbose\", `REQ: subId=${options.subId ?? \"<auto>\"}, filter=%O`, filter);\n    try {\n      sub.req();\n    } catch (err) {\n      tx.error(new FetchTillEoseFailedSignal(\"failed to send REQ\", { cause: err }));\n      removeRelayListeners();\n    }\n\n    // handle abortion\n    if (options.abortSignal?.aborted) {\n      closeSub();\n      tx.error(\n        new FetchTillEoseAbortedSignal(\n          `subscription (id: ${sub.subId}) aborted by AbortController`,\n        ),\n      );\n    }\n    options.abortSignal?.addEventListener(\"abort\", () => {\n      closeSub();\n      tx.error(\n        new FetchTillEoseAbortedSignal(\n          `subscription (id: ${sub.subId}) aborted by AbortController`,\n        ),\n      );\n    });\n\n    yield* chIter;\n  }\n}\n", "import { Filter } from \"@nostr-fetch/kernel/nostr\";\n\n/**\n * Structure of Nostr event filter except `limit`, `since` and `until`.\n */\nexport type FetchFilter = Omit<Filter, \"limit\" | \"since\" | \"until\">;\n\nexport type FetchFilterKeyName = keyof Omit<FetchFilter, \"search\">;\n\nexport type FetchFilterKeyElem<K extends FetchFilterKeyName> = Exclude<\n  FetchFilter[K],\n  undefined\n>[number];\n\n/**\n * Pair of timestamps which specifies time range of events to fetch.\n */\nexport type FetchTimeRangeFilter = Pick<Filter, \"since\" | \"until\">;\n\n/**\n * Type of errors that can be thrown from `NostrFetcher` methods.\n */\nexport class NostrFetchError extends Error {\n  static {\n    this.prototype.name = \"NostrFetchError\";\n  }\n}\n\n/* stats */\n\n/**\n * Status of relays during a fetch.\n *\n * Legend:\n *\n * - `fetching`: the fetcher is actively fetching events from the relay\n * - `completed`: the fetcher have fetched enough events from the relay\n * - `aborted`: Fetching from the relay is aborted\n * - `failed`: An error occurred during fetching from the relay\n * - `connection-failed`: An error occurred during connecting to the relay\n */\nexport type RelayStatus = \"fetching\" | \"completed\" | \"aborted\" | \"failed\" | \"connection-failed\";\n\n/**\n * Per-relay fetch statistics.\n */\nexport type RelayFetchStats = {\n  /** Status of relays during a fetch. */\n  status: RelayStatus;\n\n  /** Number of events fetched from the relay. */\n  numFetchedEvents: number;\n\n  /**\n   * \"Frontier\" of the event fetching.\n   * In other words, `created_at` of the oldest events fetched from the relay.\n   */\n  frontier: number;\n};\n\n/**\n * Various statistics of the event fetching.\n */\nexport type FetchStats = {\n  /** Elapsed time in millisecond */\n  elapsedTimeMs: number;\n  /** Overall progress of the event fetching. */\n  progress: {\n    max: number;\n    current: number;\n  };\n  /** Events and subscriptions counts. */\n  counts: {\n    /** Number of events fetched from relays so far. */\n    fetchedEvents: number;\n    /** Number of events buffered in the internal buffer. */\n    bufferedEvents: number;\n    /** Number of subscriptions opened so far. */\n    openedSubs: number;\n    /** Number of subscriptions that is running. */\n    runningSubs: number;\n  };\n  /** Per-relay fetch statistics. */\n  relays: {\n    [relayUrl: string]: RelayFetchStats;\n  };\n};\n\n/**\n * Type of functions for listening fetch statistics.\n */\nexport type FetchStatsListener = (stats: FetchStats) => void;\n", "import { DebugLogger } from \"@nostr-fetch/kernel/debugLogger\";\nimport { NostrFetcherCommonOptions } from \"@nostr-fetch/kernel/fetcherBackend\";\nimport { NostrEvent, querySupportedNips } from \"@nostr-fetch/kernel/nostr\";\nimport { normalizeRelayUrlSet } from \".\";\nimport {\n  FetchFilterKeyElem,\n  FetchFilterKeyName,\n  FetchStats,\n  FetchStatsListener,\n  NostrFetchError,\n  RelayFetchStats,\n  RelayStatus,\n} from \"./types\";\n\ntype AssertionResult =\n  | {\n      severity: \"error\" | \"warn\";\n      msg: string;\n    }\n  | {\n      severity: \"none\";\n    };\n\n/**\n * assert `req` by `assertions`.\n *\n * If there are some errors, throws `NostrFetchError` which includes all error messages raised from assertions.\n * If there are some warnings, just log them.\n */\nexport const assertReq = <T>(\n  req: T,\n  assertions: ((req: T) => AssertionResult)[],\n  logger: DebugLogger | undefined,\n): void => {\n  const errors = [];\n  for (const assert of assertions) {\n    const res = assert(req);\n\n    switch (res.severity) {\n      case \"error\":\n        logger?.log(\"error\", `assertion error: ${res.msg}`);\n        errors.push(res.msg);\n        break;\n      case \"warn\":\n        logger?.log(\"warn\", `warning: ${res.msg}`);\n        break;\n    }\n  }\n  if (errors.length > 0) {\n    const lines = errors.map((e) => `- ${e}`).join(\"\\n\");\n    throw new NostrFetchError(`Invalid request!\\n${lines}`);\n  }\n};\n\nexport function checkIfTrue<T>(\n  predicate: (req: T) => boolean,\n  severity: \"error\" | \"warn\",\n  msg: string,\n): (req: T) => AssertionResult {\n  return (req: T) => (predicate(req) ? { severity: \"none\" } : { severity, msg });\n}\n\nexport function checkIfNonEmpty<T, U>(\n  getArray: (req: T) => U[],\n  severity: \"error\" | \"warn\",\n  msg: string,\n): (req: T) => AssertionResult {\n  return (req: T) => (getArray(req).length !== 0 ? { severity: \"none\" } : { severity, msg });\n}\n\nexport function checkIfTimeRangeIsValid<T>(\n  getTimeRange: (req: T) => { since?: number; until?: number },\n  severity: \"error\" | \"warn\",\n  msg: string,\n): (req: T) => AssertionResult {\n  return (req: T) => {\n    const { since, until } = getTimeRange(req);\n\n    if (since === undefined || until === undefined) {\n      // time range is always valid if at least one of the bounds is unbounded.\n      return { severity: \"none\" };\n    }\n    return since <= until ? { severity: \"none\" } : { severity, msg };\n  };\n}\n\n/**\n * comparator represents descending order by `created_at` of events (a.k.a. \"newest to oldest\" order)\n */\nexport const createdAtDesc = (a: NostrEvent, b: NostrEvent): number => b.created_at - a.created_at;\n\n/**\n * get keys corresponds to `keyName` from the event.\n */\nexport const getKeysOfEvent = <K extends FetchFilterKeyName>(\n  keyName: K,\n  ev: NostrEvent,\n): FetchFilterKeyElem<K>[] => {\n  switch (keyName) {\n    case \"ids\":\n      return [ev.id];\n    case \"authors\":\n      return [ev.pubkey];\n    case \"kinds\":\n      return [ev.kind];\n  }\n  // tag key -> values of tags with the target name\n  const tagVals = ev.tags.filter((t) => t[0] === keyName.charAt(1)).map((t) => t[1] ?? \"\");\n  return [...new Set(tagVals)];\n};\n\n// type of a result of EventBuckets#add\ntype EventBucketAddResult =\n  | { state: \"open\" }\n  | { state: \"fulfilled\"; events: NostrEvent[] }\n  | { state: \"dropped\" };\n\n/**\n * Set of event buckets for each `key`, with limit on the number of events.\n */\nexport class EventBuckets<K> {\n  #buckets: Map<K, NostrEvent[]>;\n  #limitPerKey: number;\n\n  // pre-condition: `keys` should be deduped in advance.\n  constructor(keys: K[], limit: number) {\n    this.#buckets = new Map(keys.map((k) => [k, []]));\n    this.#limitPerKey = limit;\n  }\n\n  public getBucket(key: K): NostrEvent[] | undefined {\n    return this.#buckets.get(key);\n  }\n\n  /**\n   * Adds an event (`ev`) to the bucket for `key` if there is space.\n   *\n   * Returns a result with `state: \"fulfilled\"` and events if the bucket is just fulfilled by the addition, otherwise returns `state: \"open\"`.\n   *\n   * If the bucket is already full, drops the event and returns `state: \"dropped\"`.\n   */\n  public add(key: K, ev: NostrEvent): EventBucketAddResult {\n    const bucket = this.#buckets.get(key);\n    if (bucket === undefined) {\n      console.error(`bucket not found for key: ${key}`);\n      return { state: \"dropped\" };\n    }\n\n    if (bucket.length >= this.#limitPerKey) {\n      // bucket is already full\n      return { state: \"dropped\" };\n    }\n\n    // adding event\n    bucket.push(ev);\n    if (bucket.length === this.#limitPerKey) {\n      // just fulfilled!\n      return { state: \"fulfilled\", events: bucket };\n    }\n    return { state: \"open\" };\n  }\n\n  /**\n   * Calculates keys and limit for next request to a relay.\n   *\n   * * `keys`: (all keys) - (keys correspond to a full bucket)\n   * * `limit`: SUM( #(limit per key) - #(events in bucket) )\n   */\n  public calcKeysAndLimitForNextReq(): { keys: K[]; limit: number } {\n    return [...this.#buckets.entries()].reduce(\n      ({ keys, limit }, [key, bucket]) => {\n        const numEvents = bucket.length;\n        return {\n          keys: numEvents < this.#limitPerKey ? [...keys, key] : keys,\n          limit: limit + (this.#limitPerKey - numEvents),\n        };\n      },\n      { keys: [] as K[], limit: 0 },\n    );\n  }\n}\n\n/**\n * Map from all combinations of keys per relay URL in `keysPerRelay` to a value of type `V`.\n *\n * This has additional mapping from `key` in `keys` to array of values.\n */\nexport class KeyRelayMatrix<K extends string | number, V> {\n  #matrix: Map<string, V>;\n  #byKey: Map<K, V[]>;\n\n  // pre-condition: each array of `relayToKeys.values()` should be deduped in advance.\n  constructor(relayToKeys: Map<string, K[]>, initVal: () => V) {\n    this.#matrix = new Map();\n\n    const allKeys = [...new Set([...relayToKeys.values()].flat())]; // relayToKeys.values(): K[][]\n    this.#byKey = new Map(allKeys.map((k) => [k, []]));\n\n    for (const [r, keys] of relayToKeys) {\n      for (const k of keys) {\n        const v = initVal();\n\n        this.#matrix.set(this.#getKey(k, r), v);\n        this.#byKey.get(k)!.push(v); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n      }\n    }\n  }\n\n  #getKey(key: K, relayUrl: string): string {\n    return `${key}|${relayUrl}`;\n  }\n\n  public get(key: K, relayUrl: string): V | undefined {\n    return this.#matrix.get(this.#getKey(key, relayUrl));\n  }\n\n  public itemsByKey(key: K): V[] | undefined {\n    return this.#byKey.get(key);\n  }\n}\n\nexport interface RelayCapabilityChecker {\n  relaySupportsNips(relayUrl: string, requiredNips: number[]): Promise<boolean>;\n}\n\nclass DefaultRelayCapChecker implements RelayCapabilityChecker {\n  #supportedNipsCache: Map<string, Set<number>> = new Map();\n  #debugLogger: DebugLogger | undefined;\n\n  constructor(opts: Required<NostrFetcherCommonOptions>) {\n    if (opts.minLogLevel !== \"none\") {\n      this.#debugLogger = new DebugLogger(opts.minLogLevel);\n    }\n  }\n\n  async relaySupportsNips(relayUrl: string, requiredNips: number[]): Promise<boolean> {\n    const logger = this.#debugLogger?.subLogger(relayUrl);\n\n    if (requiredNips.length === 0) {\n      return true;\n    }\n\n    const supportSetFromCache = this.#supportedNipsCache.get(relayUrl);\n    if (supportSetFromCache !== undefined) {\n      return requiredNips.every((nip) => supportSetFromCache.has(nip));\n    }\n\n    // query supported NIP's of the relay if cache doesn't have information\n    const supportSet = await querySupportedNips(relayUrl);\n    logger?.log(\"info\", `supported NIPs: ${supportSet}`);\n\n    this.#supportedNipsCache.set(relayUrl, supportSet);\n    return requiredNips.every((nip) => supportSet.has(nip));\n  }\n}\n\nexport type RelayCapCheckerInitializer = (\n  opts: Required<NostrFetcherCommonOptions>,\n) => RelayCapabilityChecker;\n\nexport const initDefaultRelayCapChecker = (opts: Required<NostrFetcherCommonOptions>) =>\n  new DefaultRelayCapChecker(opts);\n\ntype SeenEventsReportResult<SeenOn extends boolean> = {\n  hasSeen: boolean;\n  seenOn: SeenOn extends true ? string[] : undefined;\n};\n\nexport interface SeenEvents<SeenOn extends boolean> {\n  report(event: NostrEvent, relayUrl: string): SeenEventsReportResult<SeenOn>;\n  getSeenOn(eventId: string): string[];\n}\n\nexport const initSeenEvents = <SeenOn extends boolean>(withSeenOn: SeenOn): SeenEvents<SeenOn> =>\n  withSeenOn\n    ? (new SeenOnTable() as SeenEvents<SeenOn>)\n    : (new SeenEventsSet() as SeenEvents<SeenOn>);\n\nclass SeenOnTable implements SeenEvents<true> {\n  #table = new Map<string, Set<string>>();\n\n  report(event: NostrEvent, relayUrl: string): SeenEventsReportResult<true> {\n    const seenOn = this.#table.get(event.id);\n    if (seenOn !== undefined) {\n      const updated = seenOn.add(relayUrl);\n      return { hasSeen: true, seenOn: [...updated] };\n    }\n    this.#table.set(event.id, new Set([relayUrl]));\n    return { hasSeen: false, seenOn: [relayUrl] };\n  }\n\n  getSeenOn(eventId: string): string[] {\n    return [...(this.#table.get(eventId) ?? [])];\n  }\n}\n\nclass SeenEventsSet implements SeenEvents<false> {\n  #seenIds = new Set<string>();\n\n  report(event: NostrEvent, _: string): SeenEventsReportResult<false> {\n    if (this.#seenIds.has(event.id)) {\n      return { hasSeen: true, seenOn: undefined };\n    }\n    this.#seenIds.add(event.id);\n    return { hasSeen: false, seenOn: undefined };\n  }\n\n  getSeenOn(_: string): string[] {\n    return [];\n  }\n}\n\nexport class FetchStatsManager {\n  #stats: Omit<FetchStats, \"relays\" | \"elapsedTimeMs\"> = {\n    progress: {\n      max: 1, // prevent division by 0\n      current: 0,\n    },\n    counts: {\n      fetchedEvents: 0,\n      bufferedEvents: 0,\n      openedSubs: 0,\n      runningSubs: 0,\n    },\n  };\n  #startedAt: number = performance.now();\n  #relayStatsMap: Map<string, RelayFetchStats> = new Map();\n  #cb: FetchStatsListener;\n  #timer: NodeJS.Timeout | undefined;\n\n  private constructor(cb: FetchStatsListener, notifInterval: number) {\n    this.#cb = cb;\n    this.#timer = setInterval(() => {\n      this.#cb(this.#renderStats());\n    }, notifInterval);\n  }\n\n  #renderStats(): FetchStats {\n    return {\n      ...this.#stats,\n      elapsedTimeMs: performance.now() - this.#startedAt,\n      relays: Object.fromEntries(this.#relayStatsMap),\n    };\n  }\n\n  static init(\n    cb: FetchStatsListener | undefined,\n    notifIntervalMs: number,\n  ): FetchStatsManager | undefined {\n    return cb !== undefined ? new FetchStatsManager(cb, notifIntervalMs) : undefined;\n  }\n\n  /* progress */\n  setProgressMax(max: number): void {\n    this.#stats.progress.max = Math.max(max, 1);\n  }\n\n  addProgress(delta: number): void {\n    this.#stats.progress.current += delta;\n  }\n\n  setCurrentProgress(p: number): void {\n    this.#stats.progress.current = p;\n  }\n\n  /* counts */\n  eventFetched(rurl: string): void {\n    this.#stats.counts.fetchedEvents++;\n\n    // update event count of relay\n    const rs = this.#relayStatsMap.get(rurl);\n    if (rs !== undefined) {\n      rs.numFetchedEvents++;\n    }\n  }\n\n  setNumBufferedEvents(n: number): void {\n    this.#stats.counts.bufferedEvents = n;\n  }\n\n  subOpened(): void {\n    this.#stats.counts.openedSubs++;\n    this.#stats.counts.runningSubs++;\n  }\n\n  subClosed(): void {\n    this.#stats.counts.runningSubs--;\n  }\n\n  /* relay stats */\n  initRelayStats(allReleys: string[], connectedRelays: string[], initUntil: number): void {\n    const connectedSet = new Set(connectedRelays);\n    const failedRelays = normalizeRelayUrlSet(allReleys).filter((r) => !connectedSet.has(r));\n\n    console.log(allReleys, connectedRelays, failedRelays);\n\n    const connectedEntries: [string, RelayFetchStats][] = connectedRelays.map((rurl) => [\n      rurl,\n      {\n        status: \"fetching\",\n        numFetchedEvents: 0,\n        frontier: initUntil,\n      },\n    ]);\n    const failedEntries: [string, RelayFetchStats][] = failedRelays.map((rurl) => [\n      rurl,\n      {\n        status: \"connection-failed\",\n        numFetchedEvents: 0,\n        frontier: 0,\n      },\n    ]);\n\n    this.#relayStatsMap = new Map([...connectedEntries, ...failedEntries]);\n  }\n\n  setRelayStatus(rurl: string, status: RelayStatus): void {\n    const rs = this.#relayStatsMap.get(rurl);\n    if (rs !== undefined) {\n      rs.status = status;\n    }\n  }\n\n  setRelayFrontier(rurl: string, frontier: number): void {\n    const rs = this.#relayStatsMap.get(rurl);\n    if (rs !== undefined) {\n      rs.frontier = frontier;\n    }\n  }\n\n  stop(): void {\n    if (this.#timer !== undefined) {\n      clearInterval(this.#timer);\n    }\n    // notify last stats before stopped\n    this.#cb(this.#renderStats());\n  }\n}\n\n// tracks per-relay fetch progress\nexport class ProgressTracker {\n  #progressPerRelay: Map<string, number>;\n\n  constructor(relayUrls: string[]) {\n    this.#progressPerRelay = new Map(relayUrls.map((rurl) => [rurl, 0]));\n  }\n\n  addProgress(relayUrl: string, delta: number) {\n    const prev = this.#progressPerRelay.get(relayUrl) ?? 0;\n    this.#progressPerRelay.set(relayUrl, prev + delta);\n  }\n\n  setProgress(relayUrl: string, prog: number) {\n    this.#progressPerRelay.set(relayUrl, prog);\n  }\n\n  calcTotalProgress(): number {\n    return [...this.#progressPerRelay.values()].reduce((total, prog) => total + prog);\n  }\n}\n", "import { Channel, Deferred } from \"@nostr-fetch/kernel/channel\";\nimport { verifyEventSig } from \"@nostr-fetch/kernel/crypto\";\nimport { DebugLogger } from \"@nostr-fetch/kernel/debugLogger\";\nimport {\n  EnsureRelaysOptions,\n  FetchTillEoseOptions,\n  NostrFetcherBackend,\n  NostrFetcherBackendInitializer,\n  NostrFetcherCommonOptions,\n  defaultFetcherCommonOptions,\n  isFetchTillEoseAbortedSignal,\n  isFetchTillEoseFailedSignal,\n} from \"@nostr-fetch/kernel/fetcherBackend\";\nimport { NostrEvent } from \"@nostr-fetch/kernel/nostr\";\nimport { abbreviate, currUnixtimeSec, normalizeRelayUrlSet } from \"@nostr-fetch/kernel/utils\";\n\nimport { DefaultFetcherBackend } from \"./fetcherBackend\";\nimport {\n  EventBuckets,\n  FetchStatsManager,\n  KeyRelayMatrix,\n  ProgressTracker,\n  RelayCapCheckerInitializer,\n  RelayCapabilityChecker,\n  assertReq,\n  checkIfNonEmpty,\n  checkIfTimeRangeIsValid,\n  checkIfTrue,\n  createdAtDesc,\n  getKeysOfEvent,\n  initDefaultRelayCapChecker,\n  initSeenEvents,\n} from \"./fetcherHelper\";\nimport {\n  FetchFilter,\n  FetchFilterKeyElem,\n  FetchFilterKeyName,\n  FetchStatsListener,\n  FetchTimeRangeFilter,\n  NostrFetchError,\n} from \"./types\";\n\nconst MAX_LIMIT_PER_REQ = 5000;\nconst MAX_LIMIT_PER_REQ_IN_BACKPRESSURE = 500;\n\nconst MIN_HIGH_WATER_MARK = 5000;\n\n/**\n * Nostr event with extra fields.\n */\nexport type NostrEventExt<SeenOn extends boolean = false> = NostrEvent & {\n  seenOn: SeenOn extends true ? string[] : undefined;\n};\n\n/**\n * Pair of the \"key\" of events and list of events which have that key.\n *\n * It is the type of elements of `AsyncIterable` returned from {@linkcode NostrFetcher.fetchLatestEventsPerKey}.\n */\nexport type NostrEventListWithKey<K extends FetchFilterKeyName, SeenOn extends boolean> = {\n  key: FetchFilterKeyElem<K>;\n  events: NostrEventExt<SeenOn>[];\n};\n\n/**\n * Pair of the \"key\" of an event and the event which has that key. If no event found matching the key, it will be `undefined`.\n *\n * It is the type of elements of `AsyncIterable` returned from {@linkcode NostrFetcher.fetchLastEventPerKey}.\n */\nexport type NostrEventWithKey<K extends FetchFilterKeyName, SeenOn extends boolean> = {\n  key: FetchFilterKeyElem<K>;\n  event: NostrEventExt<SeenOn> | undefined;\n};\n\n/**\n * Pair of the pubkey of event author and list of events from that author.\n *\n * It is the type of elements of `AsyncIterable` returned from {@linkcode NostrFetcher.fetchLatestEventsPerAuthor}.\n */\nexport type NostrEventListWithAuthor<SeenOn extends boolean> = {\n  author: string;\n  events: NostrEventExt<SeenOn>[];\n};\n\n/**\n * Pair of the pubkye of event author and an event from that author. If no event found from the author, it will be `undefined`.\n *\n * It is the type of elements of `AsyncIterable` returned from {@linkcode NostrFetcher.fetchLastEventPerAuthor}.\n */\nexport type NostrEventWithAuthor<SeenOn extends boolean> = {\n  author: string;\n  event: NostrEventExt<SeenOn> | undefined;\n};\n\n/**\n * Common options for all the fetch methods.\n */\nexport type FetchOptions<SeenOn extends boolean = false> = {\n  /**\n   * If true, the fetcher skips event signature verification.\n   *\n   * Note: This option has no effect under some relay pool adapters.\n   * Check the document of the relay pool adapter you want to use.\n   *\n   * @default false\n   */\n  skipVerification?: boolean;\n\n  /**\n   * If true, the fetcher skips a check that events from relays are certainly match with filters in REQuest.\n   *\n   * By default, fetchers perform the check to protect clients from malicious relays.\n   *\n   * @default false\n   */\n  skipFilterMatching?: boolean;\n\n  /**\n   * If true, `seenOn` property is appended to every returned events.\n   * The value of `seenOn` is array of relay URLs on which the event have been seen.\n   *\n   * @default false\n   */\n  withSeenOn?: SeenOn;\n\n  /**\n   * The function for listening fetch statistics.\n   *\n   * @default undefined\n   */\n  statsListener?: FetchStatsListener | undefined;\n\n  /**\n   * How often fetch statistics is notified to the listener (specified via `statsListener`), in milliseconds.\n   *\n   * @default 1000\n   */\n  statsNotifIntervalMs?: number;\n\n  /**\n   * The maximum amount of time allowed to attempt to connect to relays, in milliseconds.\n   *\n   * @default 5000\n   */\n  connectTimeoutMs?: number;\n\n  /**\n   * The `AbortSignal` used to abort an event fetching.\n   *\n   * @default undefined\n   */\n  abortSignal?: AbortSignal | undefined;\n\n  /**\n   * The maximum amount of time to wait for events from relay before a subscription is automatically aborted before EOSE, in milliseconds.\n   *\n   * @default 10000\n   */\n  abortSubBeforeEoseTimeoutMs?: number;\n\n  /**\n   * `limit` value to be used in internal subscriptions.\n   * You may want to lower this value if relays you use have limit on value of `limit`.\n   *\n   * @default 5000\n   */\n  limitPerReq?: number;\n};\n\nconst defaultFetchOptions: Required<FetchOptions> = {\n  skipVerification: false,\n  skipFilterMatching: false,\n  withSeenOn: false,\n  statsListener: undefined,\n  statsNotifIntervalMs: 1000,\n  connectTimeoutMs: 5000,\n  abortSignal: undefined,\n  abortSubBeforeEoseTimeoutMs: 10000,\n  limitPerReq: MAX_LIMIT_PER_REQ,\n};\n\n/**\n * Options for {@linkcode NostrFetcher.allEventsIterator}.\n */\nexport type AllEventsIterOptions<SeenOn extends boolean = false> = FetchOptions<SeenOn> & {\n  /**\n   * If true, the backpressure mode is enabled.\n   *\n   * In the backpressure mode, a fetcher is automatically slowed down when the consumer of events is slower than the fetcher (producer of events).\n   *\n   * This feature may be useful for jobs like transferring events from relays to other relays.\n   *\n   * @default false\n   */\n  enableBackpressure?: boolean;\n};\n\nconst defaultAllEventsIterOptions: Required<AllEventsIterOptions> = {\n  ...defaultFetchOptions,\n  enableBackpressure: false,\n};\n\n/**\n * Options for {@linkcode NostrFetcher.fetchAllEvents}.\n */\nexport type FetchAllOptions<SeenOn extends boolean = false> = FetchOptions<SeenOn> & {\n  /**\n   * If true, resulting events are sorted in \"newest to oldest\" order.\n   *\n   * @default false\n   */\n  sort?: boolean;\n};\n\nconst defaultFetchAllOptions: Required<FetchAllOptions> = {\n  ...defaultFetchOptions,\n  sort: false,\n};\n\n/**\n * Options for \"fetch latest N events\" kind of fetchers, such as {@linkcode NostrFetcher.fetchLatestEvents}.\n */\nexport type FetchLatestOptions<SeenOn extends boolean = false> = FetchOptions<SeenOn> & {\n  /**\n   * Takes unixtime in second.  If specified, fetch latest events **as of the time**.\n   *\n   * Note: it is useful only for fetching *regular* events. Using this for replaceable events will result in an unexpected behavior.\n   */\n  asOf?: number | undefined;\n\n  /**\n   * If true, the \"reduced verification\" mode is enabled.\n   *\n   * In the reduced verification mode, event signature verification is performed only to minimum amount of events enough to ensure validity.\n   *\n   * @default false\n   */\n  reduceVerification?: boolean;\n};\n\nconst defaultFetchLatestOptions: Required<FetchLatestOptions> = {\n  ...defaultFetchOptions,\n  asOf: undefined,\n  reduceVerification: true,\n};\n\n/**\n * Type of the first argument of {@linkcode NostrFetcher.fetchLatestEventsPerAuthor}/{@linkcode NostrFetcher.fetchLastEventPerAuthor}.\n */\nexport type KeysAndRelays<K extends FetchFilterKeyName> =\n  | {\n      keys: FetchFilterKeyElem<K>[];\n      relayUrls: string[];\n    }\n  | Iterable<[key: FetchFilterKeyElem<K>, relayUrls: string[]]>;\n\n/**\n * Use same relay set for all authors\n */\ntype RelaySetForAllKeys<K extends FetchFilterKeyName> = {\n  keys: FetchFilterKeyElem<K>[];\n  relayUrls: string[];\n};\n\n/**\n * Use saperate relay set for each author.  Typically `Map<string, string[]>`\n */\ntype RelaySetsPerKey<K extends FetchFilterKeyName> = Iterable<\n  [key: FetchFilterKeyElem<K>, relayUrls: string[]]\n>;\n\nconst isRelaySetForAllKeys = <K extends FetchFilterKeyName>(\n  kr: KeysAndRelays<K>,\n): kr is RelaySetForAllKeys<K> => {\n  return \"relayUrls\" in kr && \"keys\" in kr;\n};\nconst isRelaySetsPerKey = <K extends FetchFilterKeyName>(\n  kr: KeysAndRelays<K>,\n): kr is RelaySetsPerKey<K> => {\n  return Symbol.iterator in Object(kr);\n};\n\n/**\n * Type of the first argument of {@linkcode NostrFetcher.fetchLatestEventsPerAuthor}/{@linkcode NostrFetcher.fetchLastEventPerAuthor}.\n */\nexport type AuthorsAndRelays = RelaySetForAllAuthors | RelaySetsPerAuthor;\n\n/**\n * Use same relay set for all authors\n */\ntype RelaySetForAllAuthors = {\n  authors: string[];\n  relayUrls: string[];\n};\n\n/**\n * Use saperate relay set for each author.  Typically `Map<string, string[]>`\n */\ntype RelaySetsPerAuthor = Iterable<[author: string, relayUrls: string[]]>;\n\nconst isRelaySetForAllAuthors = (a2rs: AuthorsAndRelays): a2rs is RelaySetForAllAuthors => {\n  return \"relayUrls\" in a2rs && \"authors\" in a2rs;\n};\nconst isRelaySetsPerAuthor = (a2rs: AuthorsAndRelays): a2rs is RelaySetsPerAuthor => {\n  return Symbol.iterator in Object(a2rs);\n};\n\nconst adaptAuthorsAndRelays = (ar: AuthorsAndRelays): KeysAndRelays<\"authors\"> => {\n  if (isRelaySetForAllAuthors(ar)) {\n    return { keys: ar.authors, relayUrls: ar.relayUrls };\n  }\n  if (isRelaySetsPerAuthor(ar)) {\n    return ar;\n  }\n  throw Error(\"adaptAuthorsAndRelays: unreachable\");\n};\n\n/**\n * The entry point of the Nostr event fetching.\n *\n * It sits on top of a Nostr relay pool implementation which manages connections to Nostr relays. It is recommended to reuse single `NostrFetcher` instance in entire app.\n *\n * You must instantiate `NostrFetcher` with static methods like {@linkcode NostrFetcher.init} or {@linkcode NostrFetcher.withCustomPool} instead of the constructor.\n */\nexport class NostrFetcher {\n  #backend: NostrFetcherBackend;\n  #relayCapChecker: RelayCapabilityChecker;\n  #debugLogger: DebugLogger | undefined;\n\n  private constructor(\n    backend: NostrFetcherBackend,\n    relayCapChecker: RelayCapabilityChecker,\n    initOpts: Required<NostrFetcherCommonOptions>,\n  ) {\n    this.#backend = backend;\n    this.#relayCapChecker = relayCapChecker;\n\n    if (initOpts.minLogLevel !== \"none\") {\n      this.#debugLogger = new DebugLogger(initOpts.minLogLevel);\n    }\n  }\n\n  /**\n   * Initializes {@linkcode NostrFetcher} with the default relay pool implementation.\n   */\n  public static init(\n    options: NostrFetcherCommonOptions = {},\n    initRelayCapChecker: RelayCapCheckerInitializer = initDefaultRelayCapChecker,\n  ): NostrFetcher {\n    const finalOpts = { ...defaultFetcherCommonOptions, ...options };\n    const backend = new DefaultFetcherBackend(finalOpts);\n    const relayCapChecker = initRelayCapChecker(finalOpts);\n    return new NostrFetcher(backend, relayCapChecker, finalOpts);\n  }\n\n  /**\n   * Initializes {@linkcode NostrFetcher} with the given adapted custom relay pool implementation.\n   *\n   * @example\n   * ```ts\n   * const pool = new SimplePool();\n   * const fetcher = NostrFetcher.withCustomPool(simplePoolAdapter(pool));\n   * ```\n   */\n  public static withCustomPool(\n    poolAdapter: NostrFetcherBackendInitializer,\n    options: NostrFetcherCommonOptions = {},\n    initRelayCapChecker: RelayCapCheckerInitializer = initDefaultRelayCapChecker,\n  ): NostrFetcher {\n    const finalOpts = { ...defaultFetcherCommonOptions, ...options };\n    const relayCapChecker = initRelayCapChecker(finalOpts);\n    return new NostrFetcher(poolAdapter(finalOpts), relayCapChecker, finalOpts);\n  }\n\n  async #ensureRelaysWithCapCheck(\n    relayUrls: string[],\n    opts: EnsureRelaysOptions,\n    requiredNips: number[],\n  ): Promise<string[]> {\n    const connectedRelays = await this.#backend.ensureRelays(relayUrls, opts);\n\n    if (requiredNips.length === 0) {\n      // if capability check is not needed, return early\n      return connectedRelays;\n    }\n\n    this.#debugLogger?.log(\"info\", `required NIPs: ${requiredNips}`);\n\n    const res: string[] = [];\n    await Promise.all(\n      connectedRelays.map(async (rurl) => {\n        if (await this.#relayCapChecker.relaySupportsNips(rurl, requiredNips)) {\n          res.push(rurl);\n        }\n      }),\n    );\n\n    this.#debugLogger?.log(\"info\", `eligible relays: ${res}`);\n    return res;\n  }\n\n  #calcRequiredNips(filter: { search?: string }): number[] {\n    const res: number[] = [];\n    if (\"search\" in filter) {\n      res.push(50); // NIP-50: Search Capability\n    }\n    return res;\n  }\n\n  /**\n   * Returns an async iterable of all events matching the filter from Nostr relays specified by the array of URLs.\n   *\n   * You can iterate over events using `for-await-of` loop.\n   *\n   * Note: there are no guarantees about the order of returned events.\n   *\n   * Throws {@linkcode NostrFetchError} if `timeRangeFilter` is invalid (`since` > `until`).\n   */\n  public allEventsIterator<SeenOn extends boolean = false>(\n    relayUrls: string[],\n    filter: FetchFilter,\n    timeRangeFilter: FetchTimeRangeFilter,\n    options: AllEventsIterOptions<SeenOn> = {},\n  ): AsyncIterable<NostrEventExt<SeenOn>> {\n    assertReq(\n      { relayUrls, timeRangeFilter },\n      [\n        checkIfNonEmpty((r) => r.relayUrls, \"warn\", \"Specify at least 1 relay URL\"),\n        checkIfTimeRangeIsValid(\n          (r) => r.timeRangeFilter,\n          \"error\",\n          \"Invalid time range (since > until)\",\n        ),\n      ],\n      this.#debugLogger,\n    );\n\n    const filledOpts = {\n      ...defaultAllEventsIterOptions,\n      ...options,\n    } as Required<AllEventsIterOptions<SeenOn>>;\n\n    // use smaller limit if backpressure is enabled\n    const finalOpts: Required<AllEventsIterOptions<SeenOn>> = {\n      ...filledOpts,\n      limitPerReq: filledOpts.enableBackpressure\n        ? Math.min(filledOpts.limitPerReq, MAX_LIMIT_PER_REQ_IN_BACKPRESSURE)\n        : filledOpts.limitPerReq,\n    };\n    this.#debugLogger?.log(\"verbose\", \"finalOpts=%O\", finalOpts);\n\n    return this.#allEventsIterBody(relayUrls, filter, timeRangeFilter, finalOpts);\n  }\n\n  async *#allEventsIterBody<SeenOn extends boolean>(\n    relayUrls: string[],\n    filter: FetchFilter,\n    timeRangeFilter: FetchTimeRangeFilter,\n    options: Required<AllEventsIterOptions<SeenOn>>,\n  ): AsyncIterable<NostrEventExt<SeenOn>> {\n    const statsMngr = FetchStatsManager.init(options.statsListener, options.statsNotifIntervalMs);\n\n    const reqNips = this.#calcRequiredNips(filter);\n    const eligibleRelayUrls = await this.#ensureRelaysWithCapCheck(relayUrls, options, reqNips);\n\n    const highWaterMark = options.enableBackpressure\n      ? Math.max(options.limitPerReq * eligibleRelayUrls.length, MIN_HIGH_WATER_MARK)\n      : undefined;\n\n    const [tx, chIter] = Channel.make<NostrEventExt<SeenOn>>({ highWaterMark });\n    const globalSeenEvents = initSeenEvents(options.withSeenOn);\n    const initialUntil = timeRangeFilter.until ?? currUnixtimeSec();\n\n    // codes for tracking progress\n    // if `since` is undefined, duration is infinite (represented by undefined)\n    const timeRangeDur =\n      timeRangeFilter.since !== undefined\n        ? Math.max(initialUntil - timeRangeFilter.since + 1, 1)\n        : undefined;\n    const progTracker = new ProgressTracker(eligibleRelayUrls);\n    statsMngr?.setProgressMax(eligibleRelayUrls.length);\n    statsMngr?.initRelayStats(relayUrls, eligibleRelayUrls, initialUntil);\n\n    // fetch events from each relay\n    Promise.all(\n      eligibleRelayUrls.map(async (rurl) => {\n        // repeat subscription until one of the following conditions is met:\n        // 1. the relay didn't return new event\n        // 2. aborted by AbortController\n        // E. an error occurred while fetching events\n\n        const logger = this.#debugLogger?.subLogger(rurl);\n\n        let nextUntil = initialUntil;\n        const localSeenEventIds = new Set<string>();\n\n        while (true) {\n          const refinedFilter = {\n            ...timeRangeFilter,\n            ...filter,\n            until: nextUntil,\n            // relays are supposed to return *latest* events by specifying `limit` explicitly (cf. [NIP-01](https://github.com/nostr-protocol/nips/blob/master/01.md)).\n            // nostream doesn't accept a filter which has `limit` grater than 5000, so limit `limit` to this threshold or less.\n            limit: Math.min(options.limitPerReq, MAX_LIMIT_PER_REQ),\n          };\n          logger?.log(\"verbose\", \"refinedFilter=%O\", refinedFilter);\n\n          let gotNewEvent = false;\n          let oldestCreatedAt = Number.MAX_SAFE_INTEGER;\n\n          let isAboutToAbort = false;\n\n          try {\n            statsMngr?.subOpened();\n            for await (const e of this.#backend.fetchTillEose(rurl, refinedFilter, options)) {\n              // eliminate duplicated events\n              if (!localSeenEventIds.has(e.id)) {\n                // hasn't seen the event on this relay\n                gotNewEvent = true;\n                localSeenEventIds.add(e.id);\n                if (e.created_at < oldestCreatedAt) {\n                  oldestCreatedAt = e.created_at;\n                }\n\n                const { hasSeen, seenOn } = globalSeenEvents.report(e, rurl);\n                // `withSeenOn`: true  -> send the event even if it has already been seen in order to update seenOn\n                // `withSeenOn`: false -> send the event only if it hasn't been seen yet\n                if (options.withSeenOn || !hasSeen) {\n                  tx.send({ ...e, seenOn });\n                }\n\n                statsMngr?.eventFetched(rurl);\n                statsMngr?.setNumBufferedEvents(tx.numBufferedItems());\n              }\n            }\n          } catch (err) {\n            if (isFetchTillEoseFailedSignal(err)) {\n              // an error occurred while fetching events\n              logger?.log(\"error\", err);\n              statsMngr?.setRelayStatus(rurl, \"failed\");\n              break;\n            }\n            if (isFetchTillEoseAbortedSignal(err)) {\n              // fetch aborted\n              logger?.log(\"info\", err.message);\n              isAboutToAbort = true;\n            } else {\n              logger?.log(\"error\", \"unexpected error:\", err);\n              statsMngr?.setRelayStatus(rurl, \"failed\");\n              break;\n            }\n          } finally {\n            statsMngr?.subClosed();\n          }\n\n          if (!gotNewEvent) {\n            // termination contidion 1\n            logger?.log(\"info\", `got ${localSeenEventIds.size} events`);\n            statsMngr?.setRelayStatus(rurl, isAboutToAbort ? \"aborted\" : \"completed\");\n            break;\n          }\n\n          // set next `until` to `created_at` of the oldest event returned in this time.\n          nextUntil = oldestCreatedAt;\n          statsMngr?.setRelayFrontier(rurl, oldestCreatedAt);\n\n          // update progress\n          if (timeRangeDur !== undefined) {\n            progTracker.setProgress(rurl, (initialUntil - oldestCreatedAt) / timeRangeDur);\n            statsMngr?.setCurrentProgress(progTracker.calcTotalProgress());\n          }\n\n          if (options.abortSignal?.aborted) {\n            // termination contidion 2\n            logger?.log(\"info\", \"aborted\");\n            statsMngr?.setRelayStatus(rurl, \"aborted\");\n            break;\n          }\n\n          // receive backpressure: wait until the channel is drained enough\n          await tx.waitUntilDrained();\n        }\n        // subscription loop for the relay terminated\n        progTracker.setProgress(rurl, 1);\n        statsMngr?.setCurrentProgress(progTracker.calcTotalProgress());\n      }),\n    ).then(() => {\n      // all subscription loops have been terminated\n      tx.close();\n      statsMngr?.stop();\n    });\n\n    yield* chIter;\n  }\n\n  /**\n   * Fetches all events matching the filter from Nostr relays specified by the array of URLs,\n   * and collect them into an array.\n   *\n   * Note: there are no guarantees about the order of returned events if `sort` options is not specified.\n   *\n   * Throws {@linkcode NostrFetchError} if `timeRangeFilter` is invalid (`since` > `until`).\n   */\n  public async fetchAllEvents<SeenOn extends boolean = false>(\n    relayUrls: string[],\n    filter: FetchFilter,\n    timeRangeFilter: FetchTimeRangeFilter,\n    options: FetchAllOptions<SeenOn> = {},\n  ): Promise<NostrEventExt<SeenOn>[]> {\n    assertReq(\n      { relayUrls, timeRangeFilter },\n      [\n        checkIfNonEmpty((r) => r.relayUrls, \"warn\", \"Specify at least 1 relay URL\"),\n        checkIfTimeRangeIsValid(\n          (r) => r.timeRangeFilter,\n          \"error\",\n          \"Invalid time range (since > until)\",\n        ),\n      ],\n      this.#debugLogger,\n    );\n\n    const finalOpts = {\n      ...defaultFetchAllOptions,\n      ...options,\n    } as Required<FetchAllOptions<SeenOn>>;\n\n    const allEvents = this.allEventsIterator(relayUrls, filter, timeRangeFilter, {\n      ...finalOpts,\n      enableBackpressure: false,\n    });\n\n    // collect events\n    const res = await (async () => {\n      if (finalOpts.withSeenOn) {\n        const evs: Map<string, NostrEventExt<SeenOn>> = new Map();\n        for await (const ev of allEvents) {\n          evs.set(ev.id, ev);\n        }\n        return [...evs.values()];\n      }\n\n      const evs: NostrEventExt<SeenOn>[] = [];\n      for await (const ev of allEvents) {\n        evs.push(ev);\n      }\n      return evs;\n    })();\n\n    // sort events in \"newest to oldest\" order if `sort` options is specified\n    if (finalOpts.sort) {\n      res.sort(createdAtDesc);\n    }\n    return res;\n  }\n\n  /**\n   * Fetches latest events matching the filter from Nostr relays specified by the array of URLs.\n   *\n   * Events are sorted in \"newest to oldest\" order.\n   *\n   * Throws {@linkcode NostrFetchError} if `limit` is a non-positive number.\n   */\n  public async fetchLatestEvents<SeenOn extends boolean = false>(\n    relayUrls: string[],\n    filter: FetchFilter,\n    limit: number,\n    options: FetchLatestOptions<SeenOn> = {},\n  ): Promise<NostrEventExt<SeenOn>[]> {\n    assertReq(\n      { relayUrls, limit },\n      [\n        checkIfNonEmpty((r) => r.relayUrls, \"warn\", \"Specify at least 1 relay URL\"),\n        checkIfTrue((r) => r.limit > 0, \"error\", '\"limit\" should be positive number'),\n      ],\n      this.#debugLogger,\n    );\n\n    const finalOpts = {\n      ...defaultFetchLatestOptions,\n      ...options,\n    } as Required<FetchLatestOptions<SeenOn>>;\n    this.#debugLogger?.log(\"verbose\", \"finalOpts=%O\", finalOpts);\n\n    // options for subscription\n    const subOpts: FetchTillEoseOptions = {\n      ...finalOpts,\n      // skip \"full\" verification if `reduceVerification` is enabled\n      skipVerification: finalOpts.skipVerification || finalOpts.reduceVerification,\n    };\n\n    const statsMngr = FetchStatsManager.init(\n      finalOpts.statsListener,\n      finalOpts.statsNotifIntervalMs,\n    );\n\n    const reqNips = this.#calcRequiredNips(filter);\n    const eligibleRelayUrls = await this.#ensureRelaysWithCapCheck(relayUrls, finalOpts, reqNips);\n\n    const [tx, chIter] = Channel.make<NostrEvent>();\n    const globalSeenEvents = initSeenEvents(finalOpts.withSeenOn);\n    const initialUntil = finalOpts.asOf ?? currUnixtimeSec();\n\n    const progTracker = new ProgressTracker(eligibleRelayUrls);\n    statsMngr?.setProgressMax(eligibleRelayUrls.length * limit);\n    statsMngr?.initRelayStats(relayUrls, eligibleRelayUrls, initialUntil);\n\n    // fetch at most `limit` events from each relay\n    Promise.all(\n      eligibleRelayUrls.map(async (rurl) => {\n        // repeat subscription until one of the following conditions is met:\n        // 1. got enough amount of events\n        // 2. the relay didn't return new event\n        // 3. aborted by AbortController\n        // E. an error occurred while fetching events\n\n        const logger = this.#debugLogger?.subLogger(rurl);\n\n        let nextUntil = initialUntil;\n        let remainingLimit = limit;\n        const localSeenEventIds = new Set<string>();\n\n        while (true) {\n          const refinedFilter = {\n            ...filter,\n            until: nextUntil,\n            // relays are supposed to return *latest* events by specifying `limit` explicitly (cf. [NIP-01](https://github.com/nostr-protocol/nips/blob/master/01.md)).\n            // nostream doesn't accept a filter which has `limit` grater than 5000, so limit `limit` to this threshold or less.\n            limit: Math.min(remainingLimit, MAX_LIMIT_PER_REQ),\n          };\n          logger?.log(\"verbose\", \"refinedFilter=%O\", refinedFilter);\n\n          let numNewEvents = 0;\n          let oldestCreatedAt = Number.MAX_SAFE_INTEGER;\n\n          let isAboutToAbort = false;\n\n          try {\n            statsMngr?.subOpened();\n            for await (const e of this.#backend.fetchTillEose(rurl, refinedFilter, subOpts)) {\n              // eliminate duplicated events\n              if (!localSeenEventIds.has(e.id)) {\n                // hasn't seen the event on this relay\n                numNewEvents++;\n                localSeenEventIds.add(e.id);\n                if (e.created_at < oldestCreatedAt) {\n                  oldestCreatedAt = e.created_at;\n                }\n\n                const { hasSeen } = globalSeenEvents.report(e, rurl);\n                if (!hasSeen) {\n                  tx.send(e);\n                }\n\n                statsMngr?.eventFetched(rurl);\n                statsMngr?.setNumBufferedEvents(tx.numBufferedItems());\n              }\n            }\n          } catch (err) {\n            if (isFetchTillEoseFailedSignal(err)) {\n              // an error occurred while fetching events\n              logger?.log(\"error\", err);\n              statsMngr?.setRelayStatus(rurl, \"failed\");\n              break;\n            }\n            if (isFetchTillEoseAbortedSignal(err)) {\n              // fetch aborted\n              logger?.log(\"info\", err.message);\n              isAboutToAbort = true;\n            } else {\n              logger?.log(\"error\", \"unexpected error:\", err);\n              statsMngr?.setRelayStatus(rurl, \"failed\");\n              break;\n            }\n          } finally {\n            statsMngr?.subClosed();\n          }\n\n          progTracker.addProgress(rurl, Math.min(numNewEvents, remainingLimit));\n          statsMngr?.setCurrentProgress(progTracker.calcTotalProgress());\n\n          remainingLimit -= numNewEvents;\n          if (numNewEvents === 0 || remainingLimit <= 0) {\n            // termination condition 1, 2\n            logger?.log(\"info\", `got ${localSeenEventIds.size} events`);\n            statsMngr?.setRelayStatus(rurl, isAboutToAbort ? \"aborted\" : \"completed\");\n            break;\n          }\n          if (finalOpts.abortSignal?.aborted) {\n            // termination condition 3\n            logger?.log(\"info\", `aborted`);\n            statsMngr?.setRelayStatus(rurl, \"aborted\");\n            break;\n          }\n\n          // set next `until` to `created_at` of the oldest event returned in this time.\n          nextUntil = oldestCreatedAt;\n          statsMngr?.setRelayFrontier(rurl, oldestCreatedAt);\n        }\n        // subscription loop for the relay terminated\n        progTracker.setProgress(rurl, limit);\n        statsMngr?.setCurrentProgress(progTracker.calcTotalProgress());\n      }),\n    ).then(() => {\n      // all subnscription loops have been terminated\n      tx.close();\n      statsMngr?.stop();\n    });\n\n    // collect events from relays. events are already deduped\n    const evs: NostrEvent[] = [];\n    for await (const ev of chIter) {\n      evs.push(ev);\n    }\n    evs.sort(createdAtDesc);\n\n    // take latest events\n    const res = (() => {\n      // return latest `limit` events if not \"reduced verification mode\"\n      if (finalOpts.skipVerification || !finalOpts.reduceVerification) {\n        return evs.slice(0, limit);\n      }\n      // reduced verification: return latest `limit` events whose signature is valid\n      const verified: NostrEvent[] = [];\n      for (const ev of evs) {\n        if (verifyEventSig(ev)) {\n          verified.push(ev);\n          if (verified.length >= limit) {\n            break;\n          }\n        }\n      }\n      return verified;\n    })();\n\n    if (!finalOpts.withSeenOn) {\n      return res as NostrEventExt<SeenOn>[];\n    }\n    // append \"seen on\" data to events if `withSeenOn` is true.\n    return res.map((e) => {\n      return { ...e, seenOn: globalSeenEvents.getSeenOn(e.id) };\n    }) as NostrEventExt<SeenOn>[];\n  }\n\n  /**\n   * Fetches the last event matching the filter from Nostr relays specified by the array of URLs.\n   *\n   * Returns `undefined` if no event matching the filter exists in any relay.\n   */\n  public async fetchLastEvent<SeenOn extends boolean = false>(\n    relayUrls: string[],\n    filter: FetchFilter,\n    options: FetchLatestOptions<SeenOn> = {},\n  ): Promise<NostrEventExt<SeenOn> | undefined> {\n    const finalOpts = {\n      ...defaultFetchLatestOptions,\n      ...{\n        // override default value of `abortSubBeforeEoseTimeoutMs` (10000 -> 1000)\n        abortSubBeforeEoseTimeoutMs: 1000,\n        ...options,\n      },\n    } as Required<FetchLatestOptions<SeenOn>>;\n    const latest1 = await this.fetchLatestEvents(relayUrls, filter, 1, finalOpts);\n    return latest1[0];\n  }\n\n  // creates mapping of available relays to keys.\n  // returns triple: the mapping, array of all keys, and array of all relay URLs.\n  // these arrays are guaranteed to be deduped.\n  async #mapAvailableRelayToKeys<K extends FetchFilterKeyName>(\n    kr: KeysAndRelays<K>,\n    ensureOpts: EnsureRelaysOptions,\n    reqNips: number[],\n  ): Promise<\n    [\n      relayToKeys: Map<string, FetchFilterKeyElem<K>[]>,\n      allKeys: FetchFilterKeyElem<K>[],\n      allRelays: string[],\n    ]\n  > {\n    if (isRelaySetForAllKeys(kr)) {\n      assertReq(\n        kr,\n        [\n          checkIfNonEmpty((r) => r.relayUrls, \"warn\", \"Specify at least 1 relay URL\"),\n          checkIfNonEmpty((r) => r.keys as unknown[], \"warn\", \"Specify at least 1 key\"),\n        ],\n        this.#debugLogger,\n      );\n      const dedupedKeys = [...new Set(kr.keys)];\n      const eligibleRelays = await this.#ensureRelaysWithCapCheck(\n        kr.relayUrls,\n        ensureOpts,\n        reqNips,\n      );\n      return [\n        new Map(eligibleRelays.map((rurl) => [rurl, dedupedKeys])),\n        dedupedKeys,\n        eligibleRelays,\n      ];\n    }\n\n    if (isRelaySetsPerKey(kr)) {\n      const krArr = [...kr];\n      assertReq(\n        krArr,\n        [\n          checkIfNonEmpty((kr) => kr, \"warn\", \"Specify at least 1 key\"),\n          checkIfTrue(\n            (kr) => kr.every(([, relays]) => relays.length > 0),\n            \"warn\",\n            \"Specify at least 1 relay URL for all keys\",\n          ),\n        ],\n        this.#debugLogger,\n      );\n\n      const dedupedKeys = [...new Set(krArr.map(([key]) => key))];\n\n      // transpose: key to rurls -> rurl to keys\n      const rurl2keys = new Map<string, Set<FetchFilterKeyElem<K>>>();\n      for (const [key, rurls] of krArr) {\n        const normalized = normalizeRelayUrlSet(rurls);\n        for (const rurl of normalized) {\n          const keys = rurl2keys.get(rurl);\n          rurl2keys.set(rurl, keys ? keys.add(key) : new Set([key]));\n        }\n      }\n      const allRelays = [...rurl2keys.keys()];\n      const eligibleRelays = await this.#ensureRelaysWithCapCheck(allRelays, ensureOpts, reqNips);\n\n      // retain eligible relays only\n      return [\n        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n        new Map(eligibleRelays.map((rurl) => [rurl, [...rurl2keys.get(rurl)!]])),\n        dedupedKeys,\n        eligibleRelays,\n      ];\n    }\n\n    throw new NostrFetchError(\n      \"malformed first argument for fetchLatestEventsPerKey/fetchLastEventPerKey\",\n    );\n  }\n\n  /**\n   * Fetches latest up to `limit` events **for each key specified by `keyName` and `keysAndRelays`**.\n   *\n   * `keysAndRelays` can be either of two types:\n   *\n   * - `{ keys: K[], relayUrls: string[] }`: The fetcher will use the same relay set (`relayUrls`) for all `keys` to fetch events.\n   * - `Map<K, string[]>`: Key must be the key of event and value must be relay set for that key. The fetcher will use separate relay set for each key to fetch events.\n   *\n   * Result is an async iterable of `{ key: <key of events>, events: <events which have that key> }` pairs.\n   *\n   * Each array of events in the result are sorted in \"newest to oldest\" order.\n   *\n   * Throws {@linkcode NostrFetchError} if `limit` is a non-positive number.\n   */\n  public fetchLatestEventsPerKey<K extends FetchFilterKeyName, SeenOn extends boolean = false>(\n    keyName: K,\n    keysAndRelays: KeysAndRelays<K>,\n    otherFilter: Omit<FetchFilter, K>,\n    limit: number,\n    options: FetchLatestOptions<SeenOn> = {},\n  ): AsyncIterable<NostrEventListWithKey<K, SeenOn>> {\n    assertReq(\n      { limit },\n      [checkIfTrue((r) => r.limit > 0, \"error\", '\"limit\" should be positive number')],\n      this.#debugLogger,\n    );\n\n    const filledOpts = {\n      ...defaultFetchLatestOptions,\n      ...options,\n    } as Required<FetchLatestOptions<SeenOn>>;\n    this.#debugLogger?.log(\"verbose\", \"finalOpts=%O\", filledOpts);\n\n    // options for subscription\n    const finalOpts = {\n      ...filledOpts,\n      // skip \"full\" verification if `reduceVerification` is enabled\n      skipVerification: filledOpts.skipVerification || filledOpts.reduceVerification,\n    };\n\n    return this.#fetchLatestEventPerKeyBody(keyName, keysAndRelays, otherFilter, limit, finalOpts);\n  }\n\n  async *#fetchLatestEventPerKeyBody<K extends FetchFilterKeyName, SeenOn extends boolean = false>(\n    keyName: K,\n    keysAndRelays: KeysAndRelays<K>,\n    otherFilter: Omit<FetchFilter, K>,\n    limit: number,\n    options: Required<FetchLatestOptions<SeenOn>>,\n  ): AsyncIterable<NostrEventListWithKey<K, SeenOn>> {\n    const statsMngr = FetchStatsManager.init(options.statsListener, options.statsNotifIntervalMs);\n\n    // get mapping of available relay to keys and list of all keys\n    const reqNips = this.#calcRequiredNips(otherFilter);\n    const [relayToKeys, allKeys, allRelays] = await this.#mapAvailableRelayToKeys(\n      keysAndRelays,\n      options,\n      reqNips,\n    );\n    this.#debugLogger?.log(\"verbose\", \"relayToKeys=%O\", relayToKeys);\n\n    const [tx, chIter] = Channel.make<NostrEventListWithKey<K, SeenOn>>();\n    const globalSeenEvents = initSeenEvents(options.withSeenOn);\n    const initialUntil = options.asOf ?? currUnixtimeSec();\n\n    statsMngr?.setProgressMax(allKeys.length);\n    statsMngr?.initRelayStats(allRelays, [...relayToKeys.keys()], initialUntil);\n\n    // for each pair of key and relay URL, create a promise that act as \"latch\", so that the \"merger\" can wait for a subscription to complete\n    const latches = new KeyRelayMatrix(relayToKeys, () => new Deferred<NostrEvent[]>());\n\n    // the \"fetcher\" fetches events from each relay\n    Promise.all(\n      [...relayToKeys].map(async ([rurl, keys]) => {\n        // repeat subscription until one of the following conditions is met:\n        // 1. have fetched required number of events for all keys\n        // 2. the relay didn't return new event\n        // 3. aborted by AbortController\n        // E. an error occurred while fetching events\n\n        const logger = this.#debugLogger?.subLogger(rurl);\n\n        let nextUntil = initialUntil;\n        const evBucketsPerKey = new EventBuckets(keys, limit);\n        const localSeenEventIds = new Set<string>();\n\n        // procedure to complete the subscription in the middle, resolving all remaining promises.\n        // resolve() is called even if a promise is already resolved, but it's not a problem.\n        const resolveAllOnEarlyBreak = () => {\n          logger?.log(\"verbose\", `resolving bucket on early return`);\n          for (const pk of keys) {\n            latches.get(pk, rurl)?.resolve(evBucketsPerKey.getBucket(pk) ?? []);\n          }\n        };\n\n        while (true) {\n          const { keys: nextKeys, limit: nextLimit } = evBucketsPerKey.calcKeysAndLimitForNextReq();\n\n          if (nextKeys.length === 0) {\n            // termination condition 1\n            logger?.log(\"verbose\", `fulfilled buckets for all keys`);\n            statsMngr?.setRelayStatus(rurl, \"completed\");\n            break;\n          }\n\n          const refinedFilter = {\n            ...otherFilter,\n            [keyName]: nextKeys,\n            until: nextUntil,\n            limit: Math.min(nextLimit, MAX_LIMIT_PER_REQ),\n          };\n          logger?.log(\"verbose\", `refinedFilter=%O`, refinedFilter);\n\n          let gotNewEvent = false;\n          let oldestCreatedAt = Number.MAX_SAFE_INTEGER;\n\n          let isAboutToAbort = false;\n\n          try {\n            statsMngr?.subOpened();\n            for await (const e of this.#backend.fetchTillEose(rurl, refinedFilter, options)) {\n              if (!localSeenEventIds.has(e.id)) {\n                // hasn't seen the event on this relay\n                gotNewEvent = true;\n                localSeenEventIds.add(e.id);\n                if (e.created_at < oldestCreatedAt) {\n                  oldestCreatedAt = e.created_at;\n                }\n\n                globalSeenEvents.report(e, rurl);\n\n                // add the event to the bucket for the keys\n                for (const evKey of getKeysOfEvent(keyName, e)) {\n                  const addRes = evBucketsPerKey.add(evKey, e);\n                  if (addRes.state === \"fulfilled\") {\n                    // notify that event fetching is completed for the key at this relay\n                    // by resolveing the Promise corresponds to the key and the relay\n                    latches.get(evKey, rurl)?.resolve(addRes.events);\n                    logger?.log(\"verbose\", `fulfilled a bucket for key=${evKey}`);\n                  }\n                }\n\n                statsMngr?.eventFetched(rurl);\n                statsMngr?.setNumBufferedEvents(tx.numBufferedItems());\n              }\n            }\n          } catch (err) {\n            if (isFetchTillEoseFailedSignal(err)) {\n              // an error occurred while fetching events\n              logger?.log(\"error\", err);\n              statsMngr?.setRelayStatus(rurl, \"failed\");\n              resolveAllOnEarlyBreak();\n              break;\n            }\n            if (isFetchTillEoseAbortedSignal(err)) {\n              // fetch aborted\n              logger?.log(\"info\", err.message);\n              isAboutToAbort = true;\n            } else {\n              logger?.log(\"error\", \"unexpected error:\", err);\n              statsMngr?.setRelayStatus(rurl, \"failed\");\n              resolveAllOnEarlyBreak();\n              break;\n            }\n          } finally {\n            statsMngr?.subClosed();\n          }\n\n          if (!gotNewEvent) {\n            // termination condition 2\n            logger?.log(\"info\", `got ${localSeenEventIds.size} events`);\n            statsMngr?.setRelayStatus(rurl, isAboutToAbort ? \"aborted\" : \"completed\");\n            resolveAllOnEarlyBreak();\n            break;\n          }\n          if (options.abortSignal?.aborted) {\n            // termination condition 3\n            logger?.log(\"info\", `aborted`);\n            statsMngr?.setRelayStatus(rurl, isAboutToAbort ? \"aborted\" : \"completed\");\n            resolveAllOnEarlyBreak();\n            break;\n          }\n\n          // set next `until` to `created_at` of the oldest event returned in this time.\n          nextUntil = oldestCreatedAt;\n          statsMngr?.setRelayFrontier(rurl, oldestCreatedAt);\n        }\n      }),\n    );\n\n    // the \"merger\".\n    // for each key: merges result from relays, sorts events, takes latest events and sends it to the result channel.\n    Promise.all(\n      allKeys.map(async (key) => {\n        const logger = this.#debugLogger?.subLogger(abbreviate(String(key), 6));\n\n        // wait for all the buckets for the key to fulfilled\n        const evsPerRelay = await Promise.all(latches.itemsByKey(key)?.map((d) => d.promise) ?? []);\n        logger?.log(\"verbose\", `fulfilled all buckets for this key`);\n\n        // merge and sort\n        const evsDeduped = (() => {\n          const res = [];\n          const seenIds = new Set();\n\n          for (const evs of evsPerRelay) {\n            for (const ev of evs) {\n              if (!seenIds.has(ev.id)) {\n                res.push(ev);\n                seenIds.add(ev.id);\n              }\n            }\n          }\n          return res;\n        })();\n        evsDeduped.sort(createdAtDesc);\n\n        // take latest events\n        const res = (() => {\n          // return latest `limit` events if not \"reduced verification mode\"\n          if (options.skipVerification || !options.reduceVerification) {\n            return evsDeduped.slice(0, limit);\n          }\n\n          // reduced verification: return latest `limit` events whose signature is valid\n          const verified = [];\n          for (const ev of evsDeduped) {\n            if (verifyEventSig(ev)) {\n              verified.push(ev);\n              if (verified.length >= limit) {\n                break;\n              }\n            }\n          }\n          return verified;\n        })();\n\n        // send result\n        if (options.withSeenOn) {\n          // append \"seen on\" data to events if `withSeenOn` is true.\n          tx.send({\n            key,\n            events: res.map((e) => {\n              return { ...e, seenOn: globalSeenEvents.getSeenOn(e.id) };\n            }) as NostrEventExt<SeenOn>[],\n          });\n        } else {\n          tx.send({ key, events: res as NostrEventExt<SeenOn>[] });\n        }\n        statsMngr?.addProgress(1);\n      }),\n    ).then(() => {\n      // finished to fetch events for all keys\n      tx.close();\n      statsMngr?.stop();\n    });\n\n    yield* chIter;\n  }\n\n  /**\n   * Fetches the last event **for each key specified by `keysAndRelays`**.\n   *\n   * `keysAndRelays` can be either of two types:\n   *\n   * - `{ keys: K[], relayUrls: string[] }`: The fetcher will use the same relay set (`relayUrls`) for all `keys` to fetch events.\n   * - `Map<K, string[]>`: Key must be key of the event and value must be relay set for that key. The fetcher will use separate relay set for each key to fetch events.\n   *\n   * Result is an async iterable of `{ key: <key of events>, event: <the latest event which have that key> }` pairs.\n   *\n   * `event` in result will be `undefined` if no event matching the filter exists in any relay.\n   */\n  public async *fetchLastEventPerKey<K extends FetchFilterKeyName, SeenOn extends boolean = false>(\n    keyName: K,\n    keysAndRelays: KeysAndRelays<K>,\n    otherFilter: Omit<FetchFilter, K>,\n    options: FetchLatestOptions<SeenOn> = {},\n  ): AsyncIterable<NostrEventWithKey<K, SeenOn>> {\n    const finalOpts = {\n      ...defaultFetchLatestOptions,\n      ...{\n        // override default value of `abortSubBeforeEoseTimeoutMs` (10000 -> 1000)\n        abortSubBeforeEoseTimeoutMs: 1000,\n        ...options,\n      },\n    } as Required<FetchLatestOptions<SeenOn>>;\n\n    const latest1Iter = this.fetchLatestEventsPerKey(\n      keyName,\n      keysAndRelays,\n      otherFilter,\n      1,\n      finalOpts,\n    );\n    for await (const { key, events } of latest1Iter) {\n      yield { key, event: events[0] };\n    }\n  }\n\n  /**\n   * Fetches latest up to `limit` events **for each author specified by `authorsAndRelays`**.\n   *\n   * `authorsAndRelays` can be either of two types:\n   *\n   * - `{ authors: string[], relayUrls: string[] }`: The fetcher will use the same relay set (`relayUrls`) for all `authors` to fetch events.\n   * - `Map<string, string[]>`: Key must be author's pubkey and value must be relay set for that author. The fetcher will use separate relay set for each author to fetch events.\n   *\n   * Result is an async iterable of `{ author: <author's pubkey>, events: <events from the author> }` pairs.\n   *\n   * Each array of events in the result are sorted in \"newest to oldest\" order.\n   *\n   * Throws {@linkcode NostrFetchError} if `limit` is a non-positive number.\n   *\n   * Note: it's just an wrapper of `fetchLatestEventsPerKey`.\n   */\n  public async *fetchLatestEventsPerAuthor<SeenOn extends boolean = false>(\n    authorsAndRelays: AuthorsAndRelays,\n    otherFilter: Omit<FetchFilter, \"authors\">,\n    limit: number,\n    options: FetchLatestOptions<SeenOn> = {},\n  ): AsyncIterable<NostrEventListWithAuthor<SeenOn>> {\n    for await (const { key, events } of this.fetchLatestEventsPerKey(\n      \"authors\",\n      adaptAuthorsAndRelays(authorsAndRelays),\n      otherFilter,\n      limit,\n      options,\n    )) {\n      yield { author: key, events };\n    }\n  }\n\n  /**\n   * Fetches the last event **for each author specified by `authorsAndRelays`**.\n   *\n   * `authorsAndRelays` can be either of two types:\n   *\n   * - `{ authors: string[], relayUrls: string[] }`: The fetcher will use the same relay set (`relayUrls`) for all `authors` to fetch events.\n   * - `Map<string, string[]>`: Key must be author's pubkey and value must be relay set for that author. The fetcher will use separate relay set for each author to fetch events.\n   *\n   * Result is an async iterable of `{ author: <author's pubkey>, event: <the latest event from the author> }` pairs.\n   *\n   * `event` in result will be `undefined` if no event matching the filter for the author exists in any relay.\n   *\n   * Note: it's just a wrapper of `fetchLastEventPerKey`.\n   */\n  public async *fetchLastEventPerAuthor<SeenOn extends boolean = false>(\n    authorsAndRelays: AuthorsAndRelays,\n    otherFilter: Omit<FetchFilter, \"authors\">,\n    options: FetchLatestOptions<SeenOn> = {},\n  ): AsyncIterable<NostrEventWithAuthor<SeenOn>> {\n    for await (const { key, event } of this.fetchLastEventPerKey(\n      \"authors\",\n      adaptAuthorsAndRelays(authorsAndRelays),\n      otherFilter,\n      options,\n    )) {\n      yield { author: key, event };\n    }\n  }\n\n  /**\n   * Cleans up all the internal states of the fetcher.\n   */\n  public shutdown() {\n    this.#backend.shutdown();\n  }\n}\n"],
  "mappings": "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",
  "names": ["Deferred", "resolve", "reject", "v", "e", "ChannelCloseSignal", "Channel", "_Channel", "#sendQ", "#recvQ", "#closed", "#iterAlreadyStarted", "#highWaterMark", "#drainWaiter", "highWaterMark", "options", "c", "next", "d", "err", "number", "n", "isBytes", "a", "bytes", "b", "lengths", "hash", "number", "exists", "instance", "checkFinished", "output", "out", "min", "crypto", "isBytes", "a", "createView", "arr", "rotr", "word", "shift", "isLE", "hexes", "_", "i", "bytesToHex", "bytes", "hex", "utf8ToBytes", "str", "toBytes", "data", "isBytes", "concatBytes", "arrays", "sum", "i", "a", "res", "pad", "Hash", "toStr", "wrapConstructor", "hashCons", "hashC", "msg", "toBytes", "tmp", "randomBytes", "bytesLength", "crypto", "setBigUint64", "view", "byteOffset", "value", "isLE", "_32n", "_u32_max", "wh", "wl", "h", "SHA2", "Hash", "blockLen", "outputLen", "padOffset", "createView", "data", "exists", "buffer", "toBytes", "len", "pos", "take", "dataView", "out", "output", "i", "oview", "outLen", "state", "res", "to", "length", "finished", "destroyed", "Chi", "a", "b", "c", "Maj", "SHA256_K", "IV", "SHA256_W", "SHA256", "SHA2", "A", "B", "C", "D", "E", "F", "G", "H", "view", "offset", "i", "W15", "W2", "s0", "rotr", "s1", "sigma1", "T1", "T2", "sha256", "wrapConstructor", "SHA256", "utils_exports", "__export", "bitGet", "bitLen", "bitMask", "bitSet", "bytesToHex", "bytesToNumberBE", "bytesToNumberLE", "concatBytes", "createHmacDrbg", "ensureBytes", "equalBytes", "hexToBytes", "hexToNumber", "isBytes", "numberToBytesBE", "numberToBytesLE", "numberToHexUnpadded", "numberToVarBytesBE", "utf8ToBytes", "validateObject", "_0n", "_1n", "_2n", "a", "hexes", "_", "i", "bytes", "hex", "num", "asciis", "asciiToBase16", "char", "hl", "al", "array", "ai", "hi", "n1", "n2", "n", "len", "title", "expectedLength", "res", "e", "arrays", "sum", "pad", "b", "diff", "str", "pos", "value", "u8n", "data", "u8fr", "arr", "hashLen", "qByteLen", "hmacFn", "v", "k", "reset", "h", "reseed", "seed", "gen", "out", "sl", "pred", "validatorFns", "val", "object", "validators", "optValidators", "checkField", "fieldName", "type", "isOptional", "checkVal", "_0n", "_1n", "_2n", "_3n", "_4n", "_5n", "_8n", "_9n", "_16n", "mod", "a", "b", "result", "pow", "num", "power", "modulo", "res", "pow2", "x", "invert", "number", "y", "u", "v", "q", "r", "m", "n", "tonelliShanks", "P", "legendreC", "Q", "S", "Z", "p1div4", "Fp", "root", "Q1div2", "g", "t2", "ge", "FpSqrt", "c1", "n2", "nv", "i", "FIELD_FIELDS", "validateField", "field", "initial", "opts", "map", "val", "validateObject", "FpPow", "f", "num", "power", "_0n", "_1n", "p", "d", "FpInvertBatch", "nums", "tmp", "lastMultiplied", "acc", "i", "inverted", "nLength", "n", "nBitLength", "_nBitLength", "nByteLength", "Field", "ORDER", "bitLen", "isLE", "redef", "_0n", "BITS", "BYTES", "sqrtP", "FpSqrt", "f", "bitMask", "_1n", "num", "mod", "lhs", "rhs", "power", "FpPow", "invert", "lst", "FpInvertBatch", "a", "b", "c", "numberToBytesLE", "numberToBytesBE", "bytes", "bytesToNumberLE", "bytesToNumberBE", "getFieldBytesLength", "fieldOrder", "bitLength", "getMinHashLength", "length", "mapHashToField", "key", "isLE", "len", "fieldLen", "minLen", "num", "bytesToNumberBE", "bytesToNumberLE", "reduced", "mod", "_1n", "numberToBytesLE", "numberToBytesBE", "_0n", "_1n", "wNAF", "c", "bits", "constTimeNegate", "condition", "item", "neg", "opts", "W", "windows", "windowSize", "elm", "n", "p", "d", "points", "base", "window", "i", "precomputes", "f", "mask", "maxNumber", "shiftBy", "offset", "wbits", "offset1", "offset2", "cond1", "cond2", "P", "precomputesMap", "transform", "comp", "validateBasic", "curve", "validateField", "validateObject", "nLength", "validatePointOpts", "curve", "opts", "validateBasic", "validateObject", "endo", "Fp", "a", "b2n", "h2b", "utils_exports", "DER", "m", "data", "E", "len", "res", "hex", "isBytes", "l", "r", "sBytes", "s", "rBytesLeft", "sig", "slice", "h", "num", "shl", "rhl", "sl", "rl", "_0n", "_1n", "_2n", "_3n", "_4n", "weierstrassPoints", "CURVE", "toBytes", "_c", "point", "_isCompressed", "concatBytes", "fromBytes", "bytes", "tail", "x", "y", "weierstrassEquation", "b", "x2", "x3", "isWithinCurveOrder", "assertGE", "normPrivateKeyToScalar", "key", "lengths", "nByteLength", "wrapPrivateKey", "n", "bytesToHex", "bytesToNumberBE", "ensureBytes", "mod", "pointPrecomputes", "assertPrjPoint", "other", "Point", "px", "py", "pz", "p", "is0", "i", "points", "toInv", "P", "privateKey", "windowSize", "left", "right", "X1", "Y1", "Z1", "X2", "Y2", "Z2", "U1", "U2", "b3", "X3", "Y3", "Z3", "t0", "t1", "t2", "t3", "t4", "t5", "wnaf", "comp", "I", "k1neg", "k1", "k2neg", "k2", "k1p", "k2p", "d", "scalar", "fake", "f1p", "f2p", "f", "Q", "G", "mul", "sum", "iz", "z", "ax", "ay", "zz", "cofactor", "isTorsionFree", "clearCofactor", "isCompressed", "_bits", "wNAF", "validateOpts", "weierstrass", "curveDef", "CURVE_ORDER", "compressedLen", "uncompressedLen", "isValidFieldElement", "modN", "invN", "invert", "cat", "head", "y2", "isYOdd", "numToNByteStr", "numberToBytesBE", "isBiggerThanHalfOrder", "number", "HALF", "normalizeS", "slcNum", "from", "to", "Signature", "recovery", "msgHash", "rec", "bits2int_modN", "radj", "prefix", "R", "ir", "u1", "u2", "hexToBytes", "utils", "length", "getMinHashLength", "mapHashToField", "getPublicKey", "isProbPub", "item", "arr", "str", "getSharedSecret", "privateA", "publicB", "bits2int", "delta", "ORDER_MASK", "bitMask", "int2octets", "prepSig", "defaultSigOpts", "k", "hash", "randomBytes", "lowS", "prehash", "ent", "h1int", "seedArgs", "e", "seed", "k2sig", "kBytes", "ik", "q", "normS", "defaultVerOpts", "sign", "privKey", "C", "createHmacDrbg", "verify", "signature", "publicKey", "sg", "_sig", "derError", "error", "is", "HMAC", "Hash", "hash", "_key", "key", "toBytes", "blockLen", "pad", "buf", "exists", "out", "bytes", "to", "oHash", "iHash", "finished", "destroyed", "outputLen", "hmac", "message", "getHash", "hash", "key", "msgs", "hmac", "concatBytes", "randomBytes", "createCurve", "curveDef", "defHash", "create", "weierstrass", "secp256k1P", "secp256k1N", "_1n", "_2n", "divNearest", "a", "b", "sqrtMod", "y", "P", "_3n", "_6n", "_11n", "_22n", "_23n", "_44n", "_88n", "b2", "b3", "b6", "pow2", "b9", "b11", "b22", "b44", "b88", "b176", "b220", "b223", "t1", "t2", "root", "Fp", "Field", "secp256k1", "createCurve", "k", "n", "a1", "b1", "a2", "POW_2_128", "c1", "c2", "k1", "mod", "k2", "k1neg", "k2neg", "sha256", "_0n", "fe", "x", "ge", "TAGGED_HASH_PREFIXES", "taggedHash", "tag", "messages", "tagP", "tagH", "c", "concatBytes", "pointToBytes", "point", "numTo32b", "numberToBytesBE", "modP", "modN", "Point", "GmulAdd", "Q", "schnorrGetExtPubKey", "priv", "d_", "p", "lift_x", "xx", "challenge", "args", "bytesToNumberBE", "schnorrGetPublicKey", "privateKey", "schnorrSign", "message", "auxRand", "randomBytes", "m", "ensureBytes", "px", "d", "t", "rand", "k_", "rx", "e", "sig", "schnorrVerify", "signature", "publicKey", "pub", "r", "s", "R", "schnorr", "utf8Encoder", "verifyEventSig", "ev", "serializedEv", "evHash", "bytesToHex", "sha256", "schnorr", "scoreForlogLevel", "logFnForlogLevel", "DebugLogger", "_DebugLogger", "#minLevel", "#prefix", "#renderedPrefix", "minLevel", "prefix", "subPrefix", "lv", "msg", "optionalParams", "FetchTillEoseFailedSignal", "FetchTillEoseAbortedSignal", "isFetchTillEoseFailedSignal", "err", "isFetchTillEoseAbortedSignal", "defaultFetcherCommonOptions", "currUnixtimeMilli", "now", "currUnixtimeSec", "normalizeRelayUrl", "urlStr", "url", "dedup", "items", "normalizeRelayUrlSet", "relayUrls", "u", "abbreviate", "s", "affixLen", "len", "eventKind", "supportedR2CMsgTypes", "isSupportedR2CMsgType", "s", "parseR2CMessage", "rawMsg", "parsed", "err", "msgType", "subId", "ev", "validateEvent", "rawEv", "is32BytesHexStr", "tag", "e", "is64BytesHexStr", "compileFilter", "f", "ids", "kinds", "authors", "tags", "k", "getTagValuesByName", "tagName", "t", "matchWithCompiledFilter", "queryVals", "tagVals", "FilterMatcher", "#filters", "filters", "querySupportedNips", "relayUrl", "httpUrl", "toHttpUrl", "abortCtrl", "abortTimer", "resp", "relayInfo", "relayInfoHasSupportedNips", "url", "u", "generateSubId", "reqErrRegexps", "isNoticeForReqError", "notice", "r", "initRelay", "relayUrl", "options", "RelayImpl", "#relayUrl", "#ws", "#options", "#listeners", "#subscriptions", "#msgQueue", "#handleMsgsInterval", "subId", "forwardFn", "targSub", "dispatchStartedAt", "rawMsg", "parsed", "parseR2CMessage", "ev", "sub", "msg", "notice", "cb", "resolve", "reject", "isTimedout", "timeout", "ws", "e", "reducted", "filters", "generateSubId", "RelaySubscription", "type", "#relay", "#subId", "#filters", "#filterMatcher", "#abortSubTimer", "relay", "FilterMatcher", "#resetAbortSubTimer", "#clearListeners", "s", "verifyEventSig", "CLOSE_CODE_RELAY_NOT_RECONNECTABLE", "initRelayPool", "opts", "RelayPoolImpl", "WATCHDOG_INTERVAL", "WATCHDOG_CONN_TIMEOUT", "#relays", "#watchdogTimer", "#debugLogger", "options", "DebugLogger", "rurls", "#relayShouldBeReconnected", "relay", "currUnixtimeMilli", "relayUrls", "relayOpts", "relaysToConnect", "waitsForConnect", "rurl", "r", "logger", "deferred", "Deferred", "initRelay", "ev", "notice", "normalizedUrls", "normalizeRelayUrlSet", "connectedRelays", "relayUrl", "normalizedUrl", "normalizeRelayUrl", "DefaultFetcherBackend", "#relayPool", "#debugLogger", "commonOpts", "initRelayPool", "DebugLogger", "relayUrls", "options", "relayUrl", "filter", "logger", "relay", "FetchTillEoseFailedSignal", "tx", "chIter", "Channel", "onNotice", "n", "isNoticeForReqError", "sub", "err", "removeRelayListeners", "onError", "ev", "aborted", "closeSub", "FetchTillEoseAbortedSignal", "msg", "NostrFetchError", "assertReq", "req", "assertions", "logger", "errors", "assert", "res", "lines", "e", "NostrFetchError", "checkIfTrue", "predicate", "severity", "msg", "checkIfNonEmpty", "getArray", "checkIfTimeRangeIsValid", "getTimeRange", "since", "until", "createdAtDesc", "a", "b", "getKeysOfEvent", "keyName", "ev", "tagVals", "t", "EventBuckets", "#buckets", "#limitPerKey", "keys", "limit", "k", "key", "bucket", "numEvents", "KeyRelayMatrix", "#matrix", "#byKey", "relayToKeys", "initVal", "allKeys", "r", "v", "#getKey", "relayUrl", "DefaultRelayCapChecker", "#supportedNipsCache", "#debugLogger", "opts", "DebugLogger", "requiredNips", "supportSetFromCache", "nip", "supportSet", "querySupportedNips", "initDefaultRelayCapChecker", "initSeenEvents", "withSeenOn", "SeenOnTable", "SeenEventsSet", "#table", "event", "seenOn", "eventId", "#seenIds", "_", "FetchStatsManager", "_FetchStatsManager", "#stats", "#startedAt", "#relayStatsMap", "#cb", "#timer", "cb", "notifInterval", "#renderStats", "notifIntervalMs", "max", "delta", "p", "rurl", "rs", "n", "allReleys", "connectedRelays", "initUntil", "connectedSet", "failedRelays", "normalizeRelayUrlSet", "connectedEntries", "failedEntries", "status", "frontier", "ProgressTracker", "#progressPerRelay", "relayUrls", "prev", "prog", "total", "MAX_LIMIT_PER_REQ", "MAX_LIMIT_PER_REQ_IN_BACKPRESSURE", "MIN_HIGH_WATER_MARK", "defaultFetchOptions", "defaultAllEventsIterOptions", "defaultFetchAllOptions", "defaultFetchLatestOptions", "isRelaySetForAllKeys", "kr", "isRelaySetsPerKey", "isRelaySetForAllAuthors", "a2rs", "isRelaySetsPerAuthor", "adaptAuthorsAndRelays", "ar", "NostrFetcher", "_NostrFetcher", "#backend", "#relayCapChecker", "#debugLogger", "backend", "relayCapChecker", "initOpts", "DebugLogger", "options", "initRelayCapChecker", "initDefaultRelayCapChecker", "finalOpts", "defaultFetcherCommonOptions", "DefaultFetcherBackend", "poolAdapter", "#ensureRelaysWithCapCheck", "relayUrls", "opts", "requiredNips", "connectedRelays", "res", "rurl", "#calcRequiredNips", "filter", "timeRangeFilter", "assertReq", "checkIfNonEmpty", "r", "checkIfTimeRangeIsValid", "filledOpts", "#allEventsIterBody", "statsMngr", "FetchStatsManager", "reqNips", "eligibleRelayUrls", "highWaterMark", "tx", "chIter", "Channel", "globalSeenEvents", "initSeenEvents", "initialUntil", "currUnixtimeSec", "timeRangeDur", "progTracker", "ProgressTracker", "logger", "nextUntil", "localSeenEventIds", "refinedFilter", "gotNewEvent", "oldestCreatedAt", "isAboutToAbort", "e", "hasSeen", "seenOn", "err", "isFetchTillEoseFailedSignal", "isFetchTillEoseAbortedSignal", "allEvents", "evs", "ev", "createdAtDesc", "limit", "checkIfTrue", "subOpts", "remainingLimit", "numNewEvents", "verified", "verifyEventSig", "#mapAvailableRelayToKeys", "ensureOpts", "dedupedKeys", "eligibleRelays", "krArr", "relays", "key", "rurl2keys", "rurls", "normalized", "normalizeRelayUrlSet", "keys", "allRelays", "NostrFetchError", "keyName", "keysAndRelays", "otherFilter", "#fetchLatestEventPerKeyBody", "relayToKeys", "allKeys", "latches", "KeyRelayMatrix", "Deferred", "evBucketsPerKey", "EventBuckets", "resolveAllOnEarlyBreak", "pk", "nextKeys", "nextLimit", "evKey", "getKeysOfEvent", "addRes", "abbreviate", "evsPerRelay", "d", "evsDeduped", "seenIds", "latest1Iter", "events", "authorsAndRelays", "event"]
}
