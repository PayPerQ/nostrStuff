export interface Deferred<T> {
    resolve(v: T | PromiseLike<T>): void;
    reject(e?: unknown): void;
}
export declare class Deferred<T> {
    promise: Promise<T>;
    constructor();
}
export interface ChannelSender<T> {
    send(v: T): void;
    error(e: unknown): void;
    close(): void;
    waitUntilDrained(): Promise<void>;
    numBufferedItems(): number;
}
interface ChannelIter<T> {
    [Symbol.asyncIterator](): AsyncIterator<T, void, undefined>;
}
type ChannelMakeOptions = {
    highWaterMark?: number | undefined;
};
export declare class Channel<T> {
    #private;
    private constructor();
    /**
     * Makes an asynchronous channel.
     *
     * Return a pair of a sender endpoint and an iterator which iterate over items sent to the channel.
     *
     * Specifying `highWaterMark` option enables the "backpressure mode".
     * In this mode, a sender can wait until internal queue is free enough.
     */
    static make<T>(options?: ChannelMakeOptions): [ChannelSender<T>, ChannelIter<T>];
    send(v: T): void;
    error(e?: unknown): void;
    close(): void;
    waitUntilDrained(): Promise<void>;
    numBufferedItems(): number;
    private get isCompleted();
    private recv;
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<T>, void, unknown>;
}
export {};
//# sourceMappingURL=channel.d.ts.map